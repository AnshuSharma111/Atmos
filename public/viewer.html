<!DOCTYPE html>
<html>
  <head>
    <title>Atmos Emission Surveillance</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      :root {
        --primary-color: #4361ee;
        --secondary-color: #3f37c9;
        --success-color: #4cc9f0;
        --danger-color: #f72585;
        --warning-color: #f8961e;
        --background-color: #0f172a;
        --card-bg: #1e293b;
        --text-color: #f8f9fa;
        --border-radius: 12px;
        --capture-color: #ff6b6b;
      }
      
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      body { 
        background: var(--background-color); 
        color: var(--text-color);
        font-family: 'Inter', sans-serif;
        line-height: 1.6;
        height: 100vh;
        margin: 0;
        overflow-x: hidden;
      }
      
      .app-container {
        display: grid;
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr auto;
        grid-template-areas:
          "header"
          "dashboard"
          "controls";
        gap: 20px;
        padding: 20px;
        height: 100vh;
      }
      
      .header {
        grid-area: header;
        padding: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: var(--card-bg);
        border-radius: var(--border-radius);
      }
      
      .header h1 {
        font-size: 28px;
        font-weight: 700;
        color: var(--text-color);
      }
      
      .controls {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      .camera-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-top: 20px;
        height: 450px;
        overflow-y: auto;
      }
      
      .camera-container {
        background: var(--card-bg);
        border-radius: var(--border-radius);
        padding: 15px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        gap: 10px;
        position: relative;
        overflow: hidden;
        height: 220px;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .camera-container:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
      }
      
      .camera-container.active {
        border: 2px solid var(--primary-color);
      }
      
      .camera-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      
      .camera-title {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .camera-title span {
        font-size: 16px;
        font-weight: 600;
      }
      
      .camera-location {
        font-size: 12px;
        color: var(--muted-color);
        margin-left: auto;
      }
      
      .indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background-color: var(--warning-color);
      }
      
      .indicator.active {
        background-color: var(--success-color);
      }
      
      video { 
        width: 100%; 
        height: 140px;
        border-radius: var(--border-radius);
        background: #111827; 
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        object-fit: contain;
      }
      
      .camera-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 8px;
      }
      
      .camera-status {
        font-size: 12px;
        padding: 4px 8px;
        border-radius: 12px;
        background-color: var(--warning-color);
        color: #000;
      }
      
      .camera-status.connected {
        background-color: var(--success-color);
      }
      
      .empty-state {
        grid-column: 1 / -1;
        padding: 40px;
        text-align: center;
        background-color: rgba(0, 0, 0, 0.2);
        border-radius: var(--border-radius);
        color: var(--text-color);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 200px;
      }
      
      .dashboard {
        grid-area: dashboard;
        background: var(--card-bg);
        border-radius: var(--border-radius);
        padding: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      
      .dashboard-header {
        border-bottom: 1px solid #2d3748;
        padding-bottom: 15px;
        margin-bottom: 20px;
      }
      
      .controls {
        grid-area: controls;
        display: flex;
        gap: 15px;
        padding: 15px;
        background: var(--card-bg);
        border-radius: var(--border-radius);
        justify-content: center;
        align-items: center;
      }
      
      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .btn-primary {
        background-color: var(--primary-color);
        color: white;
      }
      
      .btn-primary:hover {
        background-color: var(--secondary-color);
        transform: translateY(-2px);
      }
      
      .btn-secondary {
        background-color: transparent;
        color: var(--text-color);
        border: 1px solid var(--primary-color);
      }
      
      .btn-secondary:hover {
        background-color: rgba(67, 97, 238, 0.1);
      }
      
      .status-badge {
        padding: 8px 15px;
        border-radius: 30px;
        font-size: 14px;
        font-weight: 600;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      
      .connecting { background-color: var(--warning-color); color: #000; }
      .connected { background-color: var(--success-color); color: #000; }
      .disconnected { background-color: var(--danger-color); color: white; }
      
      .video-info {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      
      .info-row {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 14px;
      }
      
      .control-group {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      
      .btn-capture {
        background-color: var(--capture-color);
        color: white;
      }
      
      .btn-capture:hover {
        background-color: #e53e3e;
        transform: translateY(-2px);
      }
      
      .btn-capture.active {
        background-color: #38a169;
      }
      
      .frame-preview {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 15px;
      }
      
      .frame-item {
        position: relative;
        width: 150px;
        height: 100px;
        border-radius: var(--border-radius);
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }
      
      .frame-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      
      .frame-timestamp {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        font-size: 10px;
        padding: 2px 5px;
        text-align: center;
      }
      
      .capture-status {
        font-size: 14px;
        padding: 4px 10px;
        border-radius: 20px;
        background-color: var(--card-bg);
        border: 1px solid #4a5568;
        color: var(--text-color);
        margin-left: 10px;
      }
      
      @media (max-width: 992px) {
        .app-container {
          grid-template-columns: 1fr;
          grid-template-areas:
            "header"
            "video"
            "dashboard"
            "controls";
        }
        
        .frame-item {
          width: 120px;
          height: 80px;
        }
      }
    </style>
  </head>
  <body>
    <div class="app-container">
      <header class="header">
        <h1>Atmos Emission Surveillance</h1>
        <div class="controls">
          <div id="status" class="status-badge disconnected">Disconnected</div>
          <button id="connectButton" class="btn btn-primary">Connect to Server</button>
        </div>
      </header>
      
      <div class="dashboard">
        <div class="dashboard-header">
          <h2>Emission Monitoring System</h2>
          <div class="control-group">
            <button id="refreshBtn" class="btn btn-primary">Refresh Cameras</button>
          </div>
        </div>
        <div class="dashboard-content">
          <div id="cameraGrid" class="camera-grid">
            <div class="empty-state">
              <p>No cameras connected</p>
              <p>Click "Connect to Server" to find available cameras</p>
            </div>
          </div>
        </div>
        
        <div class="dashboard-header" style="margin-top: 20px;">
          <h2>Frame Capture Dashboard</h2>
          <div class="control-group">
            <button id="captureBtn" class="btn btn-capture">Start Capture</button>
            <span id="captureStatus" class="capture-status">Frames: 0/10</span>
          </div>
        </div>
        <div class="dashboard-content">
          <div id="framePreview" class="frame-preview">
            <p>Captured frames will appear here.</p>
          </div>
        </div>
      </div>
      
      <div class="controls">
        <button id="connectButton" class="btn btn-primary">Connect to Stream</button>
        <button id="unmuteButton" class="btn btn-secondary" style="display: none;">Unmute Audio</button>
    
    <script>
      // Monitor video element for when it starts/stops playing
      const videoStatus = document.getElementById('videoStatus');
      
      remoteVideo.onplaying = () => {
        console.log("üé¨ Video is now playing!");
        videoStatus.textContent = "Video stream active";
        videoStatus.style.color = "#00ff00";
      };
      
      remoteVideo.onpause = () => {
        console.log("‚è∏Ô∏è Video was paused");
        videoStatus.textContent = "Video paused";
        videoStatus.style.color = "#ffaa00";
      };
      
      remoteVideo.onwaiting = () => {
        console.log("‚åõ Video is waiting for data");
        videoStatus.textContent = "Buffering...";
        videoStatus.style.color = "#ffaa00";
      };
      
      remoteVideo.onerror = (e) => {
        console.error("‚ùå Video error:", e);
        videoStatus.textContent = "Video error occurred";
        videoStatus.style.color = "#ff0000";
      };
      
      // Frame capture functionality
      const FRAMES_PER_SECOND = 2; // Capture 2 frames per second
      const MAX_FRAMES = 10; // Maximum frames to store
      const capturedFrames = []; // Array to store captured frames
      let captureInterval;
      let isCapturing = false;
      
      // Function to capture a single frame
      function captureFrame() {
        if (!activeCamera || !activeStreams[activeCamera]) {
          console.log('No active camera selected for capture');
          return null;
        }
        
        const video = document.getElementById(`camera-${activeCamera}`);
        
        // Check if video is playing
        if (!video || video.readyState < 2 || !video.srcObject) {
          console.log('Video not ready for capture');
          return null;
        }
        
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        // Set canvas dimensions to match video dimensions
        canvas.width = video.videoWidth || 640;
        canvas.height = video.videoHeight || 480;
        
        // Draw current video frame on canvas
        try {
          context.drawImage(video, 0, 0, canvas.width, canvas.height);
          
          // Convert canvas to blob
          return new Promise(resolve => {
            canvas.toBlob(blob => {
              if (!blob) {
                console.error('Failed to capture frame');
                resolve(null);
                return;
              }
              
              const timestamp = new Date().toISOString();
              const frameData = {
                blob: blob,
                timestamp: timestamp,
                cameraId: activeCamera,
                filename: `frame-${activeCamera.slice(0,5)}-${timestamp.replace(/:/g, '-')}.png`,
                url: URL.createObjectURL(blob)
              };
              
              // Add to our queue
              capturedFrames.push(frameData);
              
              // If we exceed capacity, remove oldest frame
              if (capturedFrames.length > MAX_FRAMES) {
                const removedFrame = capturedFrames.shift();
                console.log(`Removed oldest frame: ${removedFrame.filename}`);
                URL.revokeObjectURL(removedFrame.url); // Free up memory
              }
              
              console.log(`Captured frame: ${frameData.filename}`);
              resolve(frameData);
            }, 'image/png', 0.8); // 0.8 quality for better performance
          });
        } catch (e) {
          console.error('Error capturing frame:', e);
          return null;
        }
      }
      
      // Function to toggle frame capture
      async function toggleFrameCapture() {
        const captureBtn = document.getElementById('captureBtn');
        
        if (!activeCamera) {
          alert("Please select a camera first by clicking on it");
          return;
        }
        
        if (isCapturing) {
          // Stop capturing
          clearInterval(captureInterval);
          captureBtn.textContent = 'Start Capture';
          captureBtn.classList.remove('active');
          isCapturing = false;
          console.log('Frame capture stopped');
        } else {
          // Start capturing
          isCapturing = true;
          captureBtn.textContent = 'Stop Capture';
          captureBtn.classList.add('active');
          console.log('Frame capture started for camera:', activeCamera);
          
          // Calculate interval based on frames per second
          const interval = 1000 / FRAMES_PER_SECOND;
          
          // Immediate first capture
          const frame = await captureFrame();
          if (frame) updateFrameDisplay();
          
          // Set interval for subsequent captures
          captureInterval = setInterval(async () => {
            const frame = await captureFrame();
            if (frame) updateFrameDisplay();
            updateCaptureStatus();
          }, interval);
        }
      }
      
      // Function to update the frame display in the dashboard
      function updateFrameDisplay() {
        const framePreview = document.getElementById('framePreview');
        if (!framePreview) return;
        
        // Clear existing content
        framePreview.innerHTML = '';
        
        // Add each frame to the preview
        capturedFrames.forEach((frame, index) => {
          const frameElement = document.createElement('div');
          frameElement.className = 'frame-item';
          
          const img = document.createElement('img');
          img.src = frame.url;
          img.alt = `Frame ${index + 1}`;
          frameElement.appendChild(img);
          
          const timestampElem = document.createElement('div');
          timestampElem.className = 'frame-timestamp';
          
          // Format the timestamp
          const time = new Date(frame.timestamp).toLocaleTimeString();
          const camId = frame.cameraId ? frame.cameraId.slice(0, 5) : 'unknown';
          timestampElem.textContent = `${camId} @ ${time}`;
          
          frameElement.appendChild(timestampElem);
          framePreview.appendChild(frameElement);
        });
        
        // Save frames to server if we're using the server component
        saveFramesToServer();
      }
      
      // Function to save frames to server
      async function saveFramesToServer() {
        if (capturedFrames.length === 0) return;
        
        try {
          // We'll only send the last captured frame to avoid overwhelming the server
          const latestFrame = capturedFrames[capturedFrames.length - 1];
          
          const formData = new FormData();
          formData.append('frame', latestFrame.blob, latestFrame.filename);
          formData.append('cameraId', latestFrame.cameraId || 'unknown');
          
          // Replace with your server address if different
          const serverUrl = 'http://192.168.220.54:3001/api/save-frames';
          
          // Use fetch API to send the frame
          fetch(serverUrl, {
            method: 'POST',
            body: formData
          }).then(response => response.json())
            .then(data => console.log('Frame saved to server:', data))
            .catch(err => console.error('Error saving to server:', err));
        } catch (error) {
          console.error('Error in saveFramesToServer:', error);
        }
      }
      
      // Function to update capture status in the UI
      function updateCaptureStatus() {
        const statusElement = document.getElementById('captureStatus');
        if (!statusElement) return;
        
        statusElement.textContent = `Frames: ${capturedFrames.length}/${MAX_FRAMES}`;
      }
      
      // Set up capture button
      document.addEventListener('DOMContentLoaded', () => {
        const captureBtn = document.getElementById('captureBtn');
        if (captureBtn) {
          captureBtn.addEventListener('click', toggleFrameCapture);
        }
      });
    </script>
    
    <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
    <script>
      // Global variables
      let socket;
      const peerConnections = {}; // Map of broadcaster IDs to RTCPeerConnections
      const activeStreams = {}; // Map of broadcaster IDs to active streams
      let activeCamera = null; // The currently active camera for frame capture
      const statusElement = document.getElementById("status");
      const cameraGrid = document.getElementById("cameraGrid");

      // Function to update the main status display
      function updateStatus(message, type) {
        statusElement.textContent = message;
        statusElement.className = `status-badge ${type}`;
      }

      // Track monitor numbers for automatic assignment
      let monitorNumbers = {};
      let nextMonitorNumber = 1;
      
      // Function to assign a monitor number
      function getMonitorNumber(broadcasterId) {
        if (!monitorNumbers[broadcasterId]) {
          monitorNumbers[broadcasterId] = nextMonitorNumber++;
        }
        return monitorNumbers[broadcasterId];
      }
      
      // Function to reset monitor numbers when needed
      function resetMonitorNumbers() {
        monitorNumbers = {};
        nextMonitorNumber = 1;
      }
      
      // Function to create camera cell for the grid
      function createCameraCell(broadcasterId, name) {
        const cameraId = `camera-${broadcasterId}`;
        
        // Create container
        const container = document.createElement('div');
        container.className = 'camera-container';
        container.id = `container-${broadcasterId}`;
        
        // Create header
        const header = document.createElement('div');
        header.className = 'camera-header';
        
        const title = document.createElement('div');
        title.className = 'camera-title';
        
        const indicator = document.createElement('div');
        indicator.className = 'indicator';
        indicator.id = `indicator-${broadcasterId}`;
        
        // Get monitor number and assign it to this broadcaster
        const monitorNum = getMonitorNumber(broadcasterId);
        
        // Create name span with monitor number
        const nameSpan = document.createElement('span');
        nameSpan.textContent = name || `Monitor ${monitorNum}`;
        nameSpan.id = `name-${broadcasterId}`;
        
        title.appendChild(indicator);
        title.appendChild(nameSpan);
        header.appendChild(title);
        
        // Create video element
        const video = document.createElement('video');
        video.id = cameraId;
        video.className = 'camera-video';
        video.autoplay = true;
        video.playsinline = true;
        video.muted = true;
        
        // Create info section
        const infoDiv = document.createElement('div');
        infoDiv.className = 'video-info';
        
        const statusDiv = document.createElement('div');
        statusDiv.className = 'info-row';
        statusDiv.id = `status-${broadcasterId}`;
        statusDiv.textContent = 'Connecting...';
        
        infoDiv.appendChild(statusDiv);
        
        // Assemble container
        container.appendChild(header);
        container.appendChild(video);
        container.appendChild(infoDiv);
        
        // Add event listener to make this the active camera for frame capture
        container.addEventListener('click', () => {
          setActiveCamera(broadcasterId);
        });
        
        return container;
      }

      // Function to set the active camera for frame capture
      function setActiveCamera(broadcasterId) {
        // Remove active class from all cameras
        document.querySelectorAll('.camera-container').forEach(cam => {
          cam.classList.remove('active');
        });
        
        // Add active class to selected camera
        const container = document.getElementById(`container-${broadcasterId}`);
        if (container) {
          container.classList.add('active');
          activeCamera = broadcasterId;
        }
      }

      // Function to update a specific camera's status
      function updateCameraStatus(broadcasterId, message, isConnected = false) {
        const statusDiv = document.getElementById(`status-${broadcasterId}`);
        const indicator = document.getElementById(`indicator-${broadcasterId}`);
        
        if (statusDiv) {
          statusDiv.textContent = message;
        }
        
        if (indicator) {
          if (isConnected) {
            indicator.classList.add('active');
          } else {
            indicator.classList.remove('active');
          }
        }
      }

      // Function to remove a camera from the grid
      function removeCamera(broadcasterId) {
        const container = document.getElementById(`container-${broadcasterId}`);
        if (container) {
          // Stop all tracks in the stream
          if (activeStreams[broadcasterId]) {
            activeStreams[broadcasterId].getTracks().forEach(track => track.stop());
            delete activeStreams[broadcasterId];
          }
          
          // Close the peer connection
          if (peerConnections[broadcasterId]) {
            peerConnections[broadcasterId].close();
            delete peerConnections[broadcasterId];
          }
          
          // Remove the container
          container.remove();
          
          // If this was the active camera, clear it
          if (activeCamera === broadcasterId) {
            activeCamera = null;
          }
          
          // Note: we keep the monitor number assigned to this broadcaster
          // in case it reconnects, it will get the same number
        }
      }

      // Function to set up a peer connection for a specific broadcaster
      function setupPeerConnection(broadcasterId) {
        // Create new RTCPeerConnection
        const pc = new RTCPeerConnection({ 
          iceServers: [{ urls: "stun:stun.l.google.com:19302" }] 
        });
        
        // Save reference to this peer connection
        peerConnections[broadcasterId] = pc;
        
        // Handle incoming tracks
        pc.ontrack = (event) => {
          console.log(`üé• Got remote track from ${broadcasterId}`, event.track.kind);
          
          const videoElement = document.getElementById(`camera-${broadcasterId}`);
          if (videoElement && videoElement.srcObject !== event.streams[0]) {
            videoElement.srcObject = event.streams[0];
            activeStreams[broadcasterId] = event.streams[0];
            updateCameraStatus(broadcasterId, "Connected", true);
            
            // If this is the first camera, make it the active one
            if (activeCamera === null) {
              setActiveCamera(broadcasterId);
            }
          }
        };
        
        // Handle connection state changes
        pc.onconnectionstatechange = () => {
          console.log(`Connection state changed for ${broadcasterId} to: ${pc.connectionState}`);
          
          if (pc.connectionState === "connected") {
            updateCameraStatus(broadcasterId, "Connected", true);
          } else if (pc.connectionState === "disconnected" || 
                     pc.connectionState === "failed" ||
                     pc.connectionState === "closed") {
            updateCameraStatus(broadcasterId, "Disconnected", false);
          }
        };
        
        // Handle ICE connection state changes
        pc.oniceconnectionstatechange = () => {
          console.log(`ICE connection state for ${broadcasterId}: ${pc.iceConnectionState}`);
        };
        
        // Handle ice candidates
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            console.log(`üßä Sending ICE candidate to ${broadcasterId}`);
            socket.emit("ice-candidate", {
              candidate: event.candidate,
              targetBroadcasterId: broadcasterId
            });
          }
        };
        
        return pc;
      }

      // Function to connect to the socket server
      function connectToServer() {
        if (socket && socket.connected) {
          console.log("Already connected to server");
          return;
        }
        
        updateStatus("Connecting to server...", "connecting");
        
        // Get the hostname part (without port)
        const hostname = window.location.hostname;
        
        // Always use port 3001 for consistency - this must match server.js port
        let serverUrl = `http://${hostname}:3001`;
        console.log("Connecting to:", serverUrl);
        
        // Close any existing socket connection first
        if (socket) {
          socket.close();
          socket = null;
        }
        
        // Create new socket with improved connection parameters
        socket = io(serverUrl, {
          path: '/api/socketio',               // Path to the Socket.IO serverless function
          transports: ['websocket', 'polling'], // Try websocket first, fallback to polling
          timeout: 20000,                      // Increased timeout for slower networks
          reconnection: true,                  // Enable reconnection
          reconnectionAttempts: 5,             // Reasonable number of retries
          reconnectionDelay: 1000,             // Wait 1 second before first retry
          reconnectionDelayMax: 5000,          // Maximum delay between retries
          forceNew: true,                      // Force new connection to avoid conflicts
          autoConnect: true                    // Connect automatically
        });
        
        console.log("Attempting direct connection to:", serverUrl);
        
        // Set up socket event handlers
        setupSocketHandlers();
      }
      
      // Set up connect button
      document.addEventListener('DOMContentLoaded', () => {
        const connectButton = document.getElementById("connectButton");
        if (connectButton) {
          connectButton.onclick = connectToServer;
        }
        
        // Add a manual IP connection button to the header
        const headerControls = document.querySelector('.controls');
        if (headerControls) {
          const manualConnectBtn = document.createElement('button');
          manualConnectBtn.className = 'btn btn-secondary';
          manualConnectBtn.textContent = 'Connect via IP';
          manualConnectBtn.onclick = () => {
            const serverIp = prompt("Enter server IP address:", "192.168.220.54:3001");
            if (serverIp) {
              // Clean up any existing socket
              if (socket) {
                socket.disconnect();
                socket = null;
              }
              
              updateStatus(`Connecting to ${serverIp}...`, "connecting");
              // Add protocol if not included
              const serverUrl = serverIp.includes('://') ? serverIp : `http://${serverIp}`;
              
              // Close any existing socket first
              if (socket) {
                socket.close();
              }
              
              socket = io(serverUrl, {
                path: '/api/socketio',              // Path to the Socket.IO serverless function
                transports: ['websocket', 'polling'], // Try websocket first
                timeout: 20000,                     // Increased timeout
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 1000,
                forceNew: true,
                autoConnect: true
              });
              
              console.log(`Attempting manual connection to: http://${serverIp}`);
              setupSocketHandlers();
            }
          };
          headerControls.appendChild(manualConnectBtn);
        }
        
        // Set up refresh button
        const refreshBtn = document.getElementById("refreshBtn");
        if (refreshBtn) {
          refreshBtn.addEventListener('click', () => {
            if (socket && socket.connected) {
              socket.emit("list-broadcasters");
            } else {
              alert("Please connect to the server first");
            }
          });
        }
      });
      
      // Function to set up socket event handlers
      function setupSocketHandlers() {
        if (!socket) {
          console.error("Socket object not initialized");
          updateStatus("Socket initialization failed", "disconnected");
          return;
        }
        
        // Clean up any existing event listeners to avoid duplicates
        socket.off("connect");
        socket.off("connect_error");
        socket.off("connect_timeout");
        socket.off("disconnect");
        socket.off("broadcaster-list");
        
        // Handle socket connection events
        socket.on("connect", () => {
          console.log("üîå Connected to signaling server at " + socket.io.uri);
          updateStatus("Connected to server", "connected");
          
          // Reset monitor numbers when reconnecting
          resetMonitorNumbers();
          
          // Request list of available broadcasters - try both event names for compatibility
          socket.emit("viewer-connect");
          console.log("Requesting broadcaster list with viewer-connect event");
          
          // Also try the list-broadcasters event after a short delay
          setTimeout(() => {
            socket.emit("list-broadcasters");
            console.log("Also requesting with list-broadcasters event");
          }, 500);
        });
        
        socket.on("connect_error", (error) => {
          console.error("‚ö†Ô∏è Socket connection error:", error);
          const errorMessage = error.message || "Unknown error";
          updateStatus(`Connection error: ${errorMessage}`, "disconnected");
          
          // Show more detailed error info in the console
          console.log("Socket connection details:");
          console.log("- URL:", socket.io ? socket.io.uri : "unknown");
          console.log("- Transport:", socket.io && socket.io.engine ? socket.io.engine.transport.name : "unknown");
          console.log("- Connected:", socket ? socket.connected : false);
          
          // Attempt to reconnect with alternative transport if the error is related to xhr polling
          if (errorMessage.includes('xhr poll error')) {
            console.log("Detected XHR polling error, trying reconnection with websocket only...");
            
            // Close the current socket
            socket.close();
            
            // Try reconnecting with websocket only after a short delay
            setTimeout(() => {
              const hostname = window.location.hostname;
              const serverUrl = `http://${hostname}:3001`;
              
              socket = io(serverUrl, {
                transports: ['websocket'], // Try websocket only as polling is failing
                timeout: 10000,
                reconnection: true,
                reconnectionAttempts: 3,
                forceNew: true
              });
              
              // Set up handlers for the new socket
              setupSocketHandlers();
            }, 2000);
          }
          
          // Add a help message in the camera grid
          if (document.querySelector('.empty-state')) {
            document.querySelector('.empty-state').innerHTML = `
              <p>Connection Error: ${errorMessage}</p>
              <p>Try the following:</p>
              <ul style="text-align: left; display: inline-block;">
                <li>Check that the server is running</li>
                <li>Try using the "Connect via IP" button</li>
                <li>Make sure you're on the same network</li>
                <li>Check firewall settings</li>
              </ul>
            `;
          }
        });
        
        socket.on("connect_timeout", () => {
          console.error("‚åõ Socket connection timeout");
          updateStatus("Connection timeout - check server", "disconnected");
        });
        
        socket.on("disconnect", () => {
          console.log("‚ùå Disconnected from signaling server");
          updateStatus("Disconnected from server", "disconnected");
          
          // Clean up peer connections
          Object.keys(peerConnections).forEach(broadcasterId => {
            removeCamera(broadcasterId);
          });
          
          // Reset grid to empty state
          cameraGrid.innerHTML = `
            <div class="empty-state">
              <p>Disconnected from server</p>
              <p>Click "Connect to Server" to reconnect</p>
            </div>
          `;
          
          // Reset socket variable
          socket = null;
        });
        
        // Handle list of active broadcasters
        socket.on("broadcaster-list", (broadcasters) => {
          console.log("üìã Received broadcaster list:", broadcasters);
          
          if (broadcasters.length === 0) {
            cameraGrid.innerHTML = `
              <div class="empty-state">
                <p>No active cameras found</p>
                <p>Please wait for cameras to connect</p>
              </div>
            `;
            return;
          }
          
          // Clear the grid if we're refreshing
          cameraGrid.innerHTML = '';
          
          // Reset monitor numbers if we're doing a full refresh
          resetMonitorNumbers();
          
          // Add each broadcaster to the grid
          broadcasters.forEach(broadcaster => {
            // Check if we already have this broadcaster
            if (!document.getElementById(`container-${broadcaster.id}`)) {
              // If the server provides a monitor number, use it
              if (broadcaster.monitorNumber) {
                monitorNumbers[broadcaster.id] = broadcaster.monitorNumber;
                if (broadcaster.monitorNumber >= nextMonitorNumber) {
                  nextMonitorNumber = broadcaster.monitorNumber + 1;
                }
              }
              
              const cell = createCameraCell(broadcaster.id, broadcaster.name);
              cameraGrid.appendChild(cell);
              
              // Request to join this stream - ensure we're using the updated event name
              socket.emit("connect-to-broadcaster", broadcaster.id);
            }
          });
        });
        
        // Handle new broadcaster joined
        socket.on("broadcaster-joined", (broadcaster) => {
          console.log("üì¢ New broadcaster joined:", broadcaster);
          
          // Check if we already have this broadcaster
          if (!document.getElementById(`container-${broadcaster.id}`)) {
            // If the server provides a monitor number, use it
            if (broadcaster.monitorNumber) {
              monitorNumbers[broadcaster.id] = broadcaster.monitorNumber;
              if (broadcaster.monitorNumber >= nextMonitorNumber) {
                nextMonitorNumber = broadcaster.monitorNumber + 1;
              }
            }
            
            const cell = createCameraCell(broadcaster.id, broadcaster.name);
            
            // Remove empty state if this is the first camera
            if (document.querySelector('.empty-state')) {
              cameraGrid.innerHTML = '';
            }
            
            cameraGrid.appendChild(cell);
            
            // Request to join this stream
            socket.emit("connect-to-broadcaster", broadcaster.id);
          }
        });
        
        // Handle broadcaster disconnection
        socket.on("broadcaster-disconnected", (broadcasterId) => {
          console.log(`üì¢ Broadcaster disconnected: ${broadcasterId}`);
          removeCamera(broadcasterId);
          
          // Show empty state if no cameras left
          if (cameraGrid.children.length === 0) {
            cameraGrid.innerHTML = `
              <div class="empty-state">
                <p>No active cameras found</p>
                <p>Please wait for cameras to connect</p>
              </div>
            `;
          }
        });
        
        // Handle offer from broadcaster
        socket.on("offer", async (data) => {
          try {
            // Extract the SDP and broadcaster ID from whatever format it comes in
            const sdp = data.sdp || data;
            const broadcasterId = data.broadcasterId || (typeof data.target === 'string' ? data.target : null);
            
            console.log(`üì° Received offer from broadcaster ${broadcasterId}`, JSON.stringify(data).substring(0, 100) + '...');
            
            if (!broadcasterId) {
              console.error("Missing broadcaster ID in offer");
              return;
            }
            
            // Create a new peer connection for this broadcaster if needed
            if (!peerConnections[broadcasterId]) {
              setupPeerConnection(broadcasterId);
            }
            
            const pc = peerConnections[broadcasterId];
            
            try {
              // Make sure we have a valid SDP with type and sdp properties
              const properSdp = {
                type: 'offer',
                sdp: sdp.sdp || sdp
              };
              
              console.log(`Processing offer SDP for ${broadcasterId}`);
              
              // Set the remote description from the offer
              await pc.setRemoteDescription(new RTCSessionDescription(properSdp));
              console.log(`‚úÖ Remote description set for ${broadcasterId}`);
              
              // Create and send an answer
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              console.log(`üí¨ Sending answer to broadcaster ${broadcasterId}`);
              
              // Send answer in the correct format
              socket.emit("answer", {
                sdp: {
                  type: 'answer',
                  sdp: answer.sdp
                },
                targetBroadcasterId: broadcasterId
              });
              
              updateCameraStatus(broadcasterId, "Connecting...");
            } catch (err) {
              console.error(`‚ùå Error in WebRTC setup for ${broadcasterId}:`, err);
              updateCameraStatus(broadcasterId, `Error: ${err.message}`);
            }
          } catch (err) {
            console.error("‚ùå Error handling offer:", err);
          }
        });
        
        // Handle ICE candidates
        socket.on("ice-candidate", async (data) => {
          console.log("üßä Received ICE candidate:", JSON.stringify(data).substring(0, 100) + '...');
          
          // Extract data from different possible formats
          const candidate = data.candidate || data;
          const broadcasterId = data.broadcasterId || (data.sender ? null : null);
          
          if (!broadcasterId) {
            console.warn("No broadcaster ID in ICE candidate, cannot process");
            return;
          }
          
          const pc = peerConnections[broadcasterId];
          
          if (!pc || pc.connectionState === "closed") {
            console.warn(`No active connection for broadcaster ${broadcasterId}`);
            return;
          }
          
          try {
            // Ensure we have a valid ICE candidate with required fields
            const validCandidate = {
              candidate: candidate.candidate || candidate,
              sdpMLineIndex: candidate.sdpMLineIndex !== undefined ? candidate.sdpMLineIndex : 0,
              sdpMid: candidate.sdpMid || '0',
              usernameFragment: candidate.usernameFragment
            };
            
            await pc.addIceCandidate(new RTCIceCandidate(validCandidate));
            console.log(`üßä Added ICE candidate for ${broadcasterId}`);
          } catch (err) {
            console.error(`‚ùå Error adding ICE candidate for ${broadcasterId}:`, err);
            console.log("Candidate data:", candidate);
          }
        });
      }
      
      // Capture frame from active camera
      function captureFrame() {
        if (!activeCamera || !activeStreams[activeCamera]) {
          console.log('No active camera selected for capture');
          return null;
        }
        
        const video = document.getElementById(`camera-${activeCamera}`);
        
        // Check if video is playing
        if (!video || video.readyState < 2 || !video.srcObject) {
          console.log('Video not ready for capture');
          return null;
        }
        
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        // Set canvas dimensions to match video dimensions
        canvas.width = video.videoWidth || 640;
        canvas.height = video.videoHeight || 480;
        
        // Draw current video frame on canvas
        try {
          context.drawImage(video, 0, 0, canvas.width, canvas.height);
          
          // Convert canvas to blob
          return new Promise(resolve => {
            canvas.toBlob(blob => {
              if (!blob) {
                console.error('Failed to capture frame');
                resolve(null);
                return;
              }
              
              const timestamp = new Date().toISOString();
              const frameData = {
                blob: blob,
                timestamp: timestamp,
                cameraId: activeCamera,
                filename: `frame-${activeCamera.slice(0,5)}-${timestamp.replace(/:/g, '-')}.png`,
                url: URL.createObjectURL(blob)
              };
              
              // Add to our queue
              capturedFrames.push(frameData);
              
              // If we exceed capacity, remove oldest frame
              if (capturedFrames.length > MAX_FRAMES) {
                const removedFrame = capturedFrames.shift();
                console.log(`Removed oldest frame: ${removedFrame.filename}`);
                URL.revokeObjectURL(removedFrame.url); // Free up memory
              }
              
              console.log(`Captured frame: ${frameData.filename}`);
              resolve(frameData);
            }, 'image/png', 0.8); // 0.8 quality for better performance
          });
        } catch (e) {
          console.error('Error capturing frame:', e);
          return null;
        }
      }
    </script>
      </div>
    </div>
  </body>
</html>