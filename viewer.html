<!DOCTYPE html>
<html>
  <head>
    <title>Atmos Livestream Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      body { 
        background: #0f172a; 
        color: #f8f9fa;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        margin: 0;
        padding: 0;
      }
      
      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }
      
      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      
      .btn {
        background: #4361ee;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
      }
      
      .btn:hover {
        background: #3f37c9;
      }
      
      .stream-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 15px;
        max-width: 100%;
      }
      
      .stream-cell {
        background: #1e293b;
        border-radius: 8px;
        padding: 10px;
        max-width: 450px;
      }
      
      .stream-title {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      
      video {
        width: 100%;
        max-height: 300px;
        background: #111827;
        border-radius: 4px;
        object-fit: cover;
      }
      
      .indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background-color: #ff9800;
        margin-right: 8px;
      }
      
      .indicator.connected {
        background-color: #4cc9f0;
      }
      
      .status-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        background: #374151;
        border-radius: 4px;
        margin-top: 20px;
      }
      
      .empty-message {
        text-align: center;
        padding: 40px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        grid-column: 1 / -1;
      }
      
      .stream-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        padding: 8px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 0 0 8px 8px;
      }
      
      .btn-small {
        background: #4361ee;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }
      
      .btn-small:hover {
        background: #3f37c9;
      }
      
      .btn-camera {
        background: #f72585;
      }
      
      .btn-camera:hover {
        background: #c8195f;
      }
      
      .debug-info {
        font-size: 12px;
        color: #aaa;
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Atmos Livestream</h1>
        <button id="connectBtn" class="btn">Connect</button>
      </div>
      
      <div id="streamGrid" class="stream-grid">
        <div class="empty-message">
          <p>No active streams</p>
          <p>Click "Connect" to find available streams</p>
        </div>
      </div>
      
      <div class="status-bar">
        <div id="connectionStatus">Not connected</div>
      </div>
    </div>
    
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script>
      let socket;
      const peerConnections = {}; // Map of broadcasterId -> RTCPeerConnection
      const streamGrid = document.getElementById('streamGrid');
      const connectBtn = document.getElementById('connectBtn');
      const connectionStatus = document.getElementById('connectionStatus');
      
      // Set up connect button
      connectBtn.addEventListener('click', connectToServer);
      
      // Function to connect to the server
      function connectToServer() {
        updateStatus('Connecting...');
        
        // Get hostname and protocol for flexible deployment
        const hostname = window.location.hostname;
        const protocol = window.location.protocol;
        
        // Determine the server URL based on environment
        const isGitHubPages = hostname.includes('github.io');
        const isRenderDirect = hostname.includes('onrender.com');
        const isLocalhost = hostname === 'localhost' || hostname === '127.0.0.1';
        
        // Configuration for different environments
        let serverUrl;
        let socketPath;
        
        if (isGitHubPages) {
          // GitHub Pages deployment - connect to Render backend
          serverUrl = 'https://atmos-7hli.onrender.com';
          socketPath = undefined; // Render uses default path
          console.log('[VIEWER] ðŸŒ GitHub Pages mode - connecting to Render backend');
          console.log('[VIEWER] ðŸ“ Viewer: https://anshusharma111.github.io/Atmos/');
          console.log('[VIEWER] ðŸ”Œ Backend: https://atmos-7hli.onrender.com');
        } else if (isRenderDirect) {
          // Deployed directly on Render
          serverUrl = `${protocol}//${hostname}`;
          socketPath = undefined;
          console.log('[VIEWER] ðŸ”Œ Render direct mode');
        } else if (isLocalhost) {
          // Local development
          serverUrl = `http://${hostname}:3001`;
          socketPath = undefined;
          console.log('[VIEWER] ðŸ’» Local development mode');
        } else {
          // Fallback - try local network IP
          serverUrl = `http://${hostname}:3001`;
          socketPath = undefined;
          console.log('[VIEWER] âš ï¸ Fallback mode - local network');
        }
        
        console.log(`[VIEWER] âœ“ Connecting to: ${serverUrl}`);
        
        // Close any existing connection
        if (socket) {
          socket.disconnect();
        }
        
        // Connect to the server with minimal configuration
        socket = io(serverUrl, {
          path: socketPath,
          transports: ['websocket', 'polling']
        });
        
        // Set up socket event handlers
        socket.on('connect', () => {
          updateStatus('Connected');
          socket.emit('list-broadcasters');
        });
        
        socket.on('connect_error', (error) => {
          updateStatus(`Connection error: ${error.message}`);
          showEmptyState(`Connection error: ${error.message}<br>Check server status and network.`);
        });
        
        socket.on('disconnect', () => {
          updateStatus('Disconnected');
          clearAllStreams();
          showEmptyState('Disconnected from server<br>Click "Connect" to reconnect');
        });
        
        // Handle broadcaster list
        socket.on('broadcaster-list', (broadcasters) => {
          if (broadcasters.length === 0) {
            showEmptyState('No active streams found');
            return;
          }
          
          streamGrid.innerHTML = '';
          
          // Create stream cell for each broadcaster
          broadcasters.forEach(broadcaster => {
            createStreamCell(broadcaster.id, broadcaster.name || `Stream ${broadcaster.monitorNumber}`);
            socket.emit('connect-to-broadcaster', broadcaster.id);
          });
        });
        
        // Handle new broadcaster
        socket.on('broadcaster-joined', (broadcaster) => {
          if (!document.getElementById(`cell-${broadcaster.id}`)) {
            createStreamCell(broadcaster.id, broadcaster.name || `Stream ${broadcaster.monitorNumber}`);
            socket.emit('connect-to-broadcaster', broadcaster.id);
          }
        });
        
        // Handle broadcaster disconnection
        socket.on('broadcaster-disconnected', (broadcasterId) => {
          removeStream(broadcasterId);
          
          if (streamGrid.children.length === 0 || 
              (streamGrid.children.length === 1 && streamGrid.children[0].classList.contains('empty-message'))) {
            showEmptyState('No active streams found');
          }
        });
        
        // Handle WebRTC offer from broadcaster
        socket.on('offer', async (data) => {
          try {
            console.log('[OFFER] Received offer from broadcaster', {
              data,
              broadcasterId: data.broadcasterId,
              hasSdp: !!data.sdp,
              sdpType: typeof data.sdp,
              existingPeerConnections: Object.keys(peerConnections)
            });
            
            const broadcasterId = data.broadcasterId || 
                                (typeof data.target === 'string' ? data.target : null);
            
            if (!broadcasterId) {
              console.error('[OFFER] Invalid offer: missing broadcasterId');
              return;
            }
            
            console.log(`[OFFER] Processing for broadcaster: ${broadcasterId}`);
            
            if (!peerConnections[broadcasterId]) {
              console.log(`[OFFER] No existing peer connection, creating new one for ${broadcasterId}`);
              const newPc = setupPeerConnection(broadcasterId);
              if (!newPc) {
                console.error(`[OFFER] Failed to create peer connection for ${broadcasterId}`);
                return;
              }
              
              // Stream cell should already exist from broadcaster-list or broadcaster-joined
              if (!document.getElementById(`cell-${broadcasterId}`)) {
                console.warn(`[OFFER] No stream cell exists for ${broadcasterId} - creating one now`);
                // Create cell as fallback (shouldn't normally happen)
                createStreamCell(broadcasterId, 'Stream'); 
              } else {
                console.log(`[OFFER] Stream cell already exists for ${broadcasterId}`);
              }
            }
            
            const pc = peerConnections[broadcasterId];
            if (!pc) {
              console.error(`[OFFER] No valid peer connection for ${broadcasterId}`);
              return;
            }
            
            console.log(`[OFFER] Peer connection state: ${pc.signalingState}, ice: ${pc.iceConnectionState}`);
            
            // FIX: Robustly extract SDP from the signaling data
            let sdpToUse;
            console.log('[OFFER] Extracting SDP, raw data.sdp:', data.sdp);
            
            if (data.sdp && data.sdp.sdp && data.sdp.type) {
                // Case 1: Full RTCSessionDescription object
                sdpToUse = { type: data.sdp.type, sdp: data.sdp.sdp };
                console.log('[OFFER] Case 1: Full RTCSessionDescription');
            } else if (data.sdp && typeof data.sdp === 'object' && !data.sdp.type) {
                // Case 2: Broadcaster sent the RTCSessionDescription object without type field (handled by server)
                sdpToUse = { type: 'offer', sdp: data.sdp.sdp || data.sdp };
                console.log('[OFFER] Case 2: Object without type field');
            } else if (typeof data.sdp === 'string') {
                // Case 3: Raw SDP string
                sdpToUse = { type: 'offer', sdp: data.sdp };
                console.log('[OFFER] Case 3: Raw SDP string');
            } else {
                console.error('[OFFER] Invalid SDP format received:', data);
                return;
            }
            
            console.log('[OFFER] SDP to use:', { type: sdpToUse.type, sdpLength: sdpToUse.sdp?.length });
            
            // Set remote description
            let answer;
            try {
              console.log(`[OFFER] Setting remote description for ${broadcasterId}`, { type: sdpToUse.type, sdpLength: sdpToUse.sdp?.length });
              await pc.setRemoteDescription(new RTCSessionDescription(sdpToUse));
              console.log(`[OFFER] Remote description set successfully for ${broadcasterId}`);
              
              // Create and send answer
              console.log(`[OFFER] Creating answer for ${broadcasterId}`);
              answer = await pc.createAnswer();
              console.log(`[OFFER] Answer created for ${broadcasterId}`, { type: answer.type, sdpLength: answer.sdp?.length });
              
              await pc.setLocalDescription(answer);
              console.log(`[OFFER] Local description set for ${broadcasterId}`);
              
              updateStreamStatus(broadcasterId, 'Connecting...');
              console.log(`[OFFER] Status updated to Connecting for ${broadcasterId}`);
            } catch (sdpError) {
              console.error(`[OFFER] Error during SDP handling for ${broadcasterId}:`, sdpError);

              console.error(`Error in SDP handling for ${broadcasterId}:`, sdpError);
              updateStreamStatus(broadcasterId, `Connection error: ${sdpError.name}`);
              return;
            }
            
            // Send the answer back to the broadcaster via the signaling server
            socket.emit('answer', {
              sdp: answer,
              targetBroadcasterId: broadcasterId
            });
            
            console.log(`Sent answer to broadcaster ${broadcasterId}`);
            updateStreamStatus(broadcasterId, 'Connecting');
          } catch (err) {
            console.error('Error handling offer:', err);
            updateStreamStatus(broadcasterId, `Offer error: ${err.message}`);
          }
        });
        
        // Handle ICE candidates from broadcaster
        socket.on('ice-candidate', async (data) => {
          try {
            const broadcasterId = data.broadcasterId || data.from;

            if (!broadcasterId || !peerConnections[broadcasterId]) return;
            
            // Add ICE candidate to the connection
            // The candidate object needs to be a valid RTCIceCandidate
            if (data.candidate) {
                await peerConnections[broadcasterId].addIceCandidate(
                    new RTCIceCandidate(data.candidate)
                );
            }
          } catch (err) {
            console.error('Error adding ICE candidate:', err);
          }
        });
      }
      
      // Function to setup WebRTC peer connection
      function setupPeerConnection(broadcasterId) {
        console.log(`Setting up peer connection for broadcaster: ${broadcasterId}`);
        
        try {
          // Create peer connection with STUN servers for NAT traversal
          const pc = new RTCPeerConnection({
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
              { urls: 'stun:stun2.l.google.com:19302' },
              { urls: 'stun:stun.ekiga.net' },
              { urls: 'stun:stun.ideasip.com' }
            ]
          });
        
        peerConnections[broadcasterId] = pc;
        
        // Handle incoming tracks (video/audio)
        pc.ontrack = (event) => {
          console.log(`[ONTRACK] Received track from ${broadcasterId}`, {
            kind: event.track.kind,
            enabled: event.track.enabled,
            readyState: event.track.readyState,
            muted: event.track.muted,
            streamCount: event.streams?.length,
            streamId: event.streams[0]?.id
          });
          
          // Update debug info with track details
          updateDebugInfo(broadcasterId, `Track: ${event.track.kind}, enabled: ${event.track.enabled}`);
          
          const videoElement = document.getElementById(`video-${broadcasterId}`);
          console.log(`[ONTRACK] Video element for ${broadcasterId}:`, {
            exists: !!videoElement,
            currentSrc: videoElement?.srcObject?.id,
            newSrc: event.streams[0]?.id
          });
          
          if (videoElement) {
            // Check if the stream is already set
            if (videoElement.srcObject === event.streams[0]) {
                console.log(`[ONTRACK] Stream already set on video element for ${broadcasterId}. Skipping update.`);
                return;
            }
            
            console.log(`[ONTRACK] Setting video stream for ${broadcasterId}`, {
              hasStreams: !!event.streams,
              streamCount: event.streams?.length,
              stream0: event.streams[0]
            });
            
            if (event.streams && event.streams[0]) {
              
              // Set stream
              videoElement.srcObject = event.streams[0];
              console.log(`[ONTRACK] srcObject set for ${broadcasterId}`);
              
              // Monitor video element events
              videoElement.onloadedmetadata = () => {
                console.log(`[ONTRACK] Video metadata loaded for ${broadcasterId}`, {
                  videoWidth: videoElement.videoWidth,
                  videoHeight: videoElement.videoHeight,
                  duration: videoElement.duration,
                  readyState: videoElement.readyState
                });
                
                updateDebugInfo(broadcasterId, 
                  `Video: ${videoElement.videoWidth}x${videoElement.videoHeight}`);
                  
                // Attempt to play the video (it's muted, so it should play)
                videoElement.play()
                  .then(() => {
                    console.log(`[ONTRACK] Video playback started for ${broadcasterId}`);
                    updateStreamStatus(broadcasterId, 'Connected');
                  })
                  .catch(e => console.error(`[ONTRACK] Error playing video for ${broadcasterId}:`, e));
              };
              
              videoElement.onerror = (e) => {
                console.error(`[ONTRACK] Video element error for ${broadcasterId}:`, e, videoElement.error);
              };
            } else {
              console.error(`[ONTRACK] No streams in track event for ${broadcasterId}`);

              console.warn("Received empty stream array or null stream");
            }
            
            // Additional video element event listeners
            videoElement.onwaiting = () => {
              console.log(`Video waiting for data: ${broadcasterId}`);
              updateStreamStatus(broadcasterId, 'Buffering...');
            };
            
            videoElement.onplaying = () => {
              console.log(`Video playing: ${broadcasterId}`);
              updateStreamStatus(broadcasterId, 'Connected');
            };
            
            updateStreamStatus(broadcasterId, 'Connected');
          }
        };
        
        // Handle connection state changes
        pc.onconnectionstatechange = () => {
          console.log(`Connection state changed for ${broadcasterId}: ${pc.connectionState}`);
          
          if (pc.connectionState === 'connected') {
            updateStreamStatus(broadcasterId, 'Connected');
          } else if (pc.connectionState === 'disconnected' || 
              pc.connectionState === 'failed' || 
              pc.connectionState === 'closed') {
            updateStreamStatus(broadcasterId, 'Disconnected');
            console.log(`Connection lost with ${broadcasterId}`);
          }
        };
        
        // Log ICE connection state changes
        pc.oniceconnectionstatechange = () => {
          console.log(`ICE connection state for ${broadcasterId}: ${pc.iceConnectionState}`);
        };
        
        // Handle ICE candidates
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            socket.emit('ice-candidate', {
              candidate: event.candidate,
              targetBroadcasterId: broadcasterId
            });
          }
        };
        
        return pc;
        } catch (error) {
          console.error(`Error setting up peer connection: ${error.message}`);
          updateStatus(`Connection error: ${error.message}`);
          return null;
        }
      }
      
      // Function to create stream cell in the grid
      function createStreamCell(id, name) {
        const existingCell = document.getElementById(`cell-${id}`);
        if (existingCell) {
            console.warn(`Stream cell for ${id} already exists.`);
            // Update the name just in case
            const nameElement = existingCell.querySelector('.stream-title span:not(.debug-info)');
            if (nameElement) nameElement.textContent = name;
            return;
        }
        
        // Remove empty message if present
        const emptyMessage = streamGrid.querySelector('.empty-message');
        if (emptyMessage) {
            streamGrid.innerHTML = '';
        }

        const cell = document.createElement('div');
        cell.className = 'stream-cell';
        cell.id = `cell-${id}`;
        
        cell.innerHTML = `
          <div class="stream-title">
            <div style="display: flex; align-items: center;">
              <div class="indicator" id="indicator-${id}"></div>
              <span>${name}</span>
            </div>
            <span id="status-${id}">Waiting...</span>
          </div>
          <video id="video-${id}" autoplay playsinline controls muted
            style="width: 100%; height: 100%; background-color: #000; display: block; object-fit: cover;"></video>
          <div class="stream-controls">
            <button class="btn-small" onclick="handleVideoMute('${id}')">Unmute</button>
            <button class="btn-small btn-camera" onclick="switchCamera('${id}')">ðŸ“· Switch Camera</button>
            <div class="debug-info" id="debug-${id}"></div>
          </div>
        `;
        
        streamGrid.appendChild(cell);
      }
      
      // Function to remove stream
      function removeStream(id) {
        const cell = document.getElementById(`cell-${id}`);
        if (cell) {
          cell.remove();
        }
        
        // Clean up WebRTC connection
        if (peerConnections[id]) {
          try {
              peerConnections[id].close();
          } catch (e) {
              console.error('Error closing peer connection:', e);
          }
          delete peerConnections[id];
        }
      }
      
      // Function to clear all streams
      function clearAllStreams() {
        // Close all peer connections
        Object.keys(peerConnections).forEach(id => {
          if (peerConnections[id]) {
            try {
                peerConnections[id].close();
            } catch (e) {
                console.error('Error closing peer connection during cleanup:', e);
            }
          }
        });
        
        // Reset connections map and UI
        Object.keys(peerConnections).forEach(key => delete peerConnections[key]);
        streamGrid.innerHTML = ''; // Clear UI
      }
      
      // Function to toggle video mute state
      function handleVideoMute(id) {
        const video = document.getElementById(`video-${id}`);
        const btn = event.target;
        
        if (video) {
          if (video.muted) {
            video.muted = false;
            btn.textContent = 'Mute';
            // Attempt to play if it was paused due to mute/autoplay restrictions
            video.play().catch(e => console.log('Autoplay after unmute failed:', e));
          } else {
            video.muted = true;
            btn.textContent = 'Unmute';
          }
        }
      }
      
      // Function to update debug info
      function updateDebugInfo(id, info) {
        const debugElement = document.getElementById(`debug-${id}`);
        if (debugElement) {
          debugElement.textContent = info;
        }
      }
      
      // Function to switch camera
      function switchCamera(broadcasterId) {
        console.log(`[VIEWER] Requesting camera switch for broadcaster: ${broadcasterId}`);
        
        if (!socket || !socket.connected) {
          console.error('[VIEWER] Cannot switch camera - not connected to server');
          alert('Not connected to server');
          return;
        }
        
        // Send camera switch request to server, which will forward to broadcaster
        socket.emit('switch-camera', { broadcasterId });
        
        // Update status to show request sent
        updateStreamStatus(broadcasterId, 'Switching camera...');
        updateDebugInfo(broadcasterId, 'Camera switch requested');
      }
      
      // Function to update stream status
      function updateStreamStatus(id, status) {
        const statusElement = document.getElementById(`status-${id}`);
        const indicator = document.getElementById(`indicator-${id}`);
        
        if (statusElement) {
          statusElement.textContent = status;
        }
        
        if (indicator) {
          indicator.className = 'indicator' + (status === 'Connected' ? ' connected' : '');
        }
      }
      
      // Function to update connection status
      function updateStatus(status) {
        connectionStatus.textContent = status;
      }
      
      // Function to show empty state
      function showEmptyState(message) {
        streamGrid.innerHTML = `
          <div class="empty-message">
            <p>${message}</p>
          </div>
        `;
      }
    </script>
  </body>
</html>