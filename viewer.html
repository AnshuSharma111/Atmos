<!DOCTYPE html>
<html>
  <head>
    <title>Atmos Livestream Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      body { 
        background: #0f172a; 
        color: #f8f9fa;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        margin: 0;
        padding: 0;
      }
      
      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }
      
      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      
      .btn {
        background: #4361ee;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
      }
      
      .btn:hover {
        background: #3f37c9;
      }
      
      .stream-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 15px;
        max-width: 100%;
      }
      
      .stream-cell {
        background: #1e293b;
        border-radius: 8px;
        padding: 10px;
        max-width: 450px;
      }
      
      .stream-title {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      
      video {
        width: 100%;
        max-height: 300px;
        background: #111827;
        border-radius: 4px;
        object-fit: cover;
      }
      
      .indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background-color: #ff9800;
        margin-right: 8px;
      }
      
      .indicator.connected {
        background-color: #4cc9f0;
      }
      
      .status-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        background: #374151;
        border-radius: 4px;
        margin-top: 20px;
      }
      
      .empty-message {
        text-align: center;
        padding: 40px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        grid-column: 1 / -1;
      }
      
      .stream-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        padding: 8px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 0 0 8px 8px;
      }
      
      .btn-small {
        background: #4361ee;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }
      
      .btn-small:hover {
        background: #3f37c9;
      }
      
      .btn-camera {
        background: #f72585;
      }
      
      .btn-camera:hover {
        background: #c8195f;
      }
      
      .debug-info {
        font-size: 12px;
        color: #aaa;
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      
      /* Dashboard Styles */
      .dashboard-section {
        margin-top: 30px;
        padding-top: 20px;
        border-top: 2px solid #374151;
      }
      
      .dashboard-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }
      
      .dashboard-title {
        font-size: 20px;
        font-weight: 600;
      }
      
      .frame-count {
        font-size: 14px;
        color: #9ca3af;
      }
      
      .dashboard-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 15px;
      }
      
      .frame-card {
        background: #1e293b;
        border-radius: 8px;
        padding: 10px;
        position: relative;
        overflow: hidden;
      }
      
      .frame-image {
        width: 100%;
        height: 150px;
        object-fit: cover;
        border-radius: 4px;
        background: #111827;
      }
      
      .frame-info {
        margin-top: 8px;
        font-size: 12px;
        color: #9ca3af;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .frame-broadcaster {
        font-weight: 500;
        color: #4cc9f0;
      }
      
      .frame-timestamp {
        font-size: 11px;
      }
      
      .dashboard-empty {
        text-align: center;
        padding: 40px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        color: #6b7280;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Atmos Livestream</h1>
        <button id="connectBtn" class="btn">Connect</button>
      </div>
      
      <div id="streamGrid" class="stream-grid">
        <div class="empty-message">
          <p>No active streams</p>
          <p>Click "Connect" to find available streams</p>
        </div>
      </div>
      
      <div class="status-bar">
        <div id="connectionStatus">Not connected</div>
      </div>
      
      <!-- Dashboard Section -->
      <div class="dashboard-section">
        <div class="dashboard-header">
          <h2 class="dashboard-title">ðŸ“¸ Frame Dashboard</h2>
          <span class="frame-count" id="frameCount">0 / 10 frames captured</span>
        </div>
        <div id="dashboardGrid" class="dashboard-grid">
          <div class="dashboard-empty">
            <p>No frames captured yet</p>
            <p style="font-size: 12px; margin-top: 8px;">Frames will be automatically captured from all active streams</p>
          </div>
        </div>
      </div>
    </div>
    
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script src="config.js"></script>
    <script>
      // Use configuration from config.js
      const CONFIG = window.ATMOS_CONFIG || {
        getServerUrl: () => 'http://localhost:3001',
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
        dashboard: { maxFrames: 10, captureInterval: 3000, frameQuality: 0.8 },
        socketConfig: { transports: ['websocket', 'polling'] },
        debug: false
      };
      
      let socket;
      const peerConnections = {}; // Map of broadcasterId -> RTCPeerConnection
      const streamGrid = document.getElementById('streamGrid');
      const connectBtn = document.getElementById('connectBtn');
      const connectionStatus = document.getElementById('connectionStatus');
      
      // Dashboard frame management (from config)
      const MAX_FRAMES = CONFIG.dashboard.maxFrames;
      const CAPTURE_INTERVAL = CONFIG.dashboard.captureInterval;
      const FRAME_QUALITY = CONFIG.dashboard.frameQuality;
      let capturedFrames = []; // Array to store frames (FIFO queue)
      let captureIntervals = {}; // Map of broadcasterId -> interval ID
      const dashboardGrid = document.getElementById('dashboardGrid');
      const frameCountElement = document.getElementById('frameCount');
      
      // Set up connect button
      connectBtn.addEventListener('click', connectToServer);
      
      // Function to connect to the server
      function connectToServer() {
        updateStatus('Connecting...');
        
        // Use configuration to get server URL
        const serverUrl = CONFIG.getServerUrl();
        
        if (CONFIG.debug) {
          console.log('[VIEWER] ðŸ”Œ Connecting to server...');
          console.log('[VIEWER] ï¿½ Server URL:', serverUrl);
          console.log('[VIEWER] ðŸŒ Environment:', CONFIG.environment);
        }
        
        console.log(`[VIEWER] âœ“ Connecting to: ${serverUrl}`);
        
        // Close any existing connection
        if (socket) {
          socket.disconnect();
        }
        
        // Connect to the server with configuration
        socket = io(serverUrl, CONFIG.socketConfig);
        
        // Set up socket event handlers
        socket.on('connect', () => {
          updateStatus('Connected');
          socket.emit('list-broadcasters');
        });
        
        socket.on('connect_error', (error) => {
          updateStatus(`Connection error: ${error.message}`);
          showEmptyState(`Connection error: ${error.message}<br>Check server status and network.`);
        });
        
        socket.on('disconnect', () => {
          updateStatus('Disconnected');
          clearAllStreams();
          showEmptyState('Disconnected from server<br>Click "Connect" to reconnect');
        });
        
        // Handle broadcaster list
        socket.on('broadcaster-list', (broadcasters) => {
          if (broadcasters.length === 0) {
            showEmptyState('No active streams found');
            return;
          }
          
          streamGrid.innerHTML = '';
          
          // Create stream cell for each broadcaster
          broadcasters.forEach(broadcaster => {
            createStreamCell(broadcaster.id, broadcaster.name || `Stream ${broadcaster.monitorNumber}`);
            socket.emit('connect-to-broadcaster', broadcaster.id);
          });
        });
        
        // Handle new broadcaster
        socket.on('broadcaster-joined', (broadcaster) => {
          if (!document.getElementById(`cell-${broadcaster.id}`)) {
            createStreamCell(broadcaster.id, broadcaster.name || `Stream ${broadcaster.monitorNumber}`);
            socket.emit('connect-to-broadcaster', broadcaster.id);
          }
        });
        
        // Handle broadcaster disconnection
        socket.on('broadcaster-disconnected', (broadcasterId) => {
          removeStream(broadcasterId);
          
          if (streamGrid.children.length === 0 || 
              (streamGrid.children.length === 1 && streamGrid.children[0].classList.contains('empty-message'))) {
            showEmptyState('No active streams found');
          }
        });
        
        // Handle WebRTC offer from broadcaster
        socket.on('offer', async (data) => {
          try {
            console.log('[OFFER] Received offer from broadcaster', {
              data,
              broadcasterId: data.broadcasterId,
              hasSdp: !!data.sdp,
              sdpType: typeof data.sdp,
              existingPeerConnections: Object.keys(peerConnections)
            });
            
            const broadcasterId = data.broadcasterId || 
                                (typeof data.target === 'string' ? data.target : null);
            
            if (!broadcasterId) {
              console.error('[OFFER] Invalid offer: missing broadcasterId');
              return;
            }
            
            console.log(`[OFFER] Processing for broadcaster: ${broadcasterId}`);
            
            if (!peerConnections[broadcasterId]) {
              console.log(`[OFFER] No existing peer connection, creating new one for ${broadcasterId}`);
              const newPc = setupPeerConnection(broadcasterId);
              if (!newPc) {
                console.error(`[OFFER] Failed to create peer connection for ${broadcasterId}`);
                return;
              }
              
              // Stream cell should already exist from broadcaster-list or broadcaster-joined
              if (!document.getElementById(`cell-${broadcasterId}`)) {
                console.warn(`[OFFER] No stream cell exists for ${broadcasterId} - creating one now`);
                // Create cell as fallback (shouldn't normally happen)
                createStreamCell(broadcasterId, 'Stream'); 
              } else {
                console.log(`[OFFER] Stream cell already exists for ${broadcasterId}`);
              }
            }
            
            const pc = peerConnections[broadcasterId];
            if (!pc) {
              console.error(`[OFFER] No valid peer connection for ${broadcasterId}`);
              return;
            }
            
            console.log(`[OFFER] Peer connection state: ${pc.signalingState}, ice: ${pc.iceConnectionState}`);
            
            // FIX: Robustly extract SDP from the signaling data
            let sdpToUse;
            console.log('[OFFER] Extracting SDP, raw data.sdp:', data.sdp);
            
            if (data.sdp && data.sdp.sdp && data.sdp.type) {
                // Case 1: Full RTCSessionDescription object
                sdpToUse = { type: data.sdp.type, sdp: data.sdp.sdp };
                console.log('[OFFER] Case 1: Full RTCSessionDescription');
            } else if (data.sdp && typeof data.sdp === 'object' && !data.sdp.type) {
                // Case 2: Broadcaster sent the RTCSessionDescription object without type field (handled by server)
                sdpToUse = { type: 'offer', sdp: data.sdp.sdp || data.sdp };
                console.log('[OFFER] Case 2: Object without type field');
            } else if (typeof data.sdp === 'string') {
                // Case 3: Raw SDP string
                sdpToUse = { type: 'offer', sdp: data.sdp };
                console.log('[OFFER] Case 3: Raw SDP string');
            } else {
                console.error('[OFFER] Invalid SDP format received:', data);
                return;
            }
            
            console.log('[OFFER] SDP to use:', { type: sdpToUse.type, sdpLength: sdpToUse.sdp?.length });
            
            // Set remote description
            let answer;
            try {
              console.log(`[OFFER] Setting remote description for ${broadcasterId}`, { type: sdpToUse.type, sdpLength: sdpToUse.sdp?.length });
              await pc.setRemoteDescription(new RTCSessionDescription(sdpToUse));
              console.log(`[OFFER] Remote description set successfully for ${broadcasterId}`);
              
              // Create and send answer
              console.log(`[OFFER] Creating answer for ${broadcasterId}`);
              answer = await pc.createAnswer();
              console.log(`[OFFER] Answer created for ${broadcasterId}`, { type: answer.type, sdpLength: answer.sdp?.length });
              
              await pc.setLocalDescription(answer);
              console.log(`[OFFER] Local description set for ${broadcasterId}`);
              
              updateStreamStatus(broadcasterId, 'Connecting...');
              console.log(`[OFFER] Status updated to Connecting for ${broadcasterId}`);
            } catch (sdpError) {
              console.error(`[OFFER] Error during SDP handling for ${broadcasterId}:`, sdpError);

              console.error(`Error in SDP handling for ${broadcasterId}:`, sdpError);
              updateStreamStatus(broadcasterId, `Connection error: ${sdpError.name}`);
              return;
            }
            
            // Send the answer back to the broadcaster via the signaling server
            socket.emit('answer', {
              sdp: answer,
              targetBroadcasterId: broadcasterId
            });
            
            console.log(`Sent answer to broadcaster ${broadcasterId}`);
            updateStreamStatus(broadcasterId, 'Connecting');
          } catch (err) {
            console.error('Error handling offer:', err);
            updateStreamStatus(broadcasterId, `Offer error: ${err.message}`);
          }
        });
        
        // Handle ICE candidates from broadcaster
        socket.on('ice-candidate', async (data) => {
          try {
            const broadcasterId = data.broadcasterId || data.from;

            if (!broadcasterId || !peerConnections[broadcasterId]) return;
            
            // Add ICE candidate to the connection
            // The candidate object needs to be a valid RTCIceCandidate
            if (data.candidate) {
                await peerConnections[broadcasterId].addIceCandidate(
                    new RTCIceCandidate(data.candidate)
                );
            }
          } catch (err) {
            console.error('Error adding ICE candidate:', err);
          }
        });
      }
      
      // Function to setup WebRTC peer connection
      function setupPeerConnection(broadcasterId) {
        console.log(`Setting up peer connection for broadcaster: ${broadcasterId}`);
        
        try {
          // Create peer connection with STUN servers from config
          const pc = new RTCPeerConnection({
            iceServers: CONFIG.iceServers
          });
        
        peerConnections[broadcasterId] = pc;
        
        // Handle incoming tracks (video/audio)
        pc.ontrack = (event) => {
          console.log(`[ONTRACK] Received track from ${broadcasterId}`, {
            kind: event.track.kind,
            enabled: event.track.enabled,
            readyState: event.track.readyState,
            muted: event.track.muted,
            streamCount: event.streams?.length,
            streamId: event.streams[0]?.id
          });
          
          // Update debug info with track details
          updateDebugInfo(broadcasterId, `Track: ${event.track.kind}, enabled: ${event.track.enabled}`);
          
          const videoElement = document.getElementById(`video-${broadcasterId}`);
          console.log(`[ONTRACK] Video element for ${broadcasterId}:`, {
            exists: !!videoElement,
            currentSrc: videoElement?.srcObject?.id,
            newSrc: event.streams[0]?.id
          });
          
          if (videoElement) {
            // Check if the stream is already set
            if (videoElement.srcObject === event.streams[0]) {
                console.log(`[ONTRACK] Stream already set on video element for ${broadcasterId}. Skipping update.`);
                return;
            }
            
            console.log(`[ONTRACK] Setting video stream for ${broadcasterId}`, {
              hasStreams: !!event.streams,
              streamCount: event.streams?.length,
              stream0: event.streams[0]
            });
            
            if (event.streams && event.streams[0]) {
              
              // Set stream
              videoElement.srcObject = event.streams[0];
              console.log(`[ONTRACK] srcObject set for ${broadcasterId}`);
              
              // Monitor video element events
              videoElement.onloadedmetadata = () => {
                console.log(`[ONTRACK] Video metadata loaded for ${broadcasterId}`, {
                  videoWidth: videoElement.videoWidth,
                  videoHeight: videoElement.videoHeight,
                  duration: videoElement.duration,
                  readyState: videoElement.readyState
                });
                
                updateDebugInfo(broadcasterId, 
                  `Video: ${videoElement.videoWidth}x${videoElement.videoHeight}`);
                  
                // Attempt to play the video (it's muted, so it should play)
                videoElement.play()
                  .then(() => {
                    console.log(`[ONTRACK] Video playback started for ${broadcasterId}`);
                    updateStreamStatus(broadcasterId, 'Connected');
                  })
                  .catch(e => console.error(`[ONTRACK] Error playing video for ${broadcasterId}:`, e));
              };
              
              videoElement.onerror = (e) => {
                console.error(`[ONTRACK] Video element error for ${broadcasterId}:`, e, videoElement.error);
              };
            } else {
              console.error(`[ONTRACK] No streams in track event for ${broadcasterId}`);

              console.warn("Received empty stream array or null stream");
            }
            
            // Additional video element event listeners
            videoElement.onwaiting = () => {
              console.log(`Video waiting for data: ${broadcasterId}`);
              updateStreamStatus(broadcasterId, 'Buffering...');
            };
            
            videoElement.onplaying = () => {
              console.log(`Video playing: ${broadcasterId}`);
              updateStreamStatus(broadcasterId, 'Connected');
              
              // Start capturing frames for dashboard when video starts playing
              startFrameCapture(broadcasterId);
            };
            
            updateStreamStatus(broadcasterId, 'Connected');
          }
        };
        
        // Handle connection state changes
        pc.onconnectionstatechange = () => {
          console.log(`Connection state changed for ${broadcasterId}: ${pc.connectionState}`);
          
          if (pc.connectionState === 'connected') {
            updateStreamStatus(broadcasterId, 'Connected');
          } else if (pc.connectionState === 'disconnected' || 
              pc.connectionState === 'failed' || 
              pc.connectionState === 'closed') {
            updateStreamStatus(broadcasterId, 'Disconnected');
            console.log(`Connection lost with ${broadcasterId}`);
          }
        };
        
        // Log ICE connection state changes
        pc.oniceconnectionstatechange = () => {
          console.log(`ICE connection state for ${broadcasterId}: ${pc.iceConnectionState}`);
        };
        
        // Handle ICE candidates
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            socket.emit('ice-candidate', {
              candidate: event.candidate,
              targetBroadcasterId: broadcasterId
            });
          }
        };
        
        return pc;
        } catch (error) {
          console.error(`Error setting up peer connection: ${error.message}`);
          updateStatus(`Connection error: ${error.message}`);
          return null;
        }
      }
      
      // Function to create stream cell in the grid
      function createStreamCell(id, name) {
        const existingCell = document.getElementById(`cell-${id}`);
        if (existingCell) {
            console.warn(`Stream cell for ${id} already exists.`);
            // Update the name just in case
            const nameElement = existingCell.querySelector('.stream-title span:not(.debug-info)');
            if (nameElement) nameElement.textContent = name;
            return;
        }
        
        // Remove empty message if present
        const emptyMessage = streamGrid.querySelector('.empty-message');
        if (emptyMessage) {
            streamGrid.innerHTML = '';
        }

        const cell = document.createElement('div');
        cell.className = 'stream-cell';
        cell.id = `cell-${id}`;
        
        cell.innerHTML = `
          <div class="stream-title">
            <div style="display: flex; align-items: center;">
              <div class="indicator" id="indicator-${id}"></div>
              <span>${name}</span>
            </div>
            <span id="status-${id}">Waiting...</span>
          </div>
          <video id="video-${id}" autoplay playsinline controls muted
            style="width: 100%; height: 100%; background-color: #000; display: block; object-fit: cover;"></video>
          <div class="stream-controls">
            <button class="btn-small" onclick="handleVideoMute('${id}')">Unmute</button>
            <button class="btn-small btn-camera" onclick="switchCamera('${id}')">ðŸ“· Switch Camera</button>
            <div class="debug-info" id="debug-${id}"></div>
          </div>
        `;
        
        streamGrid.appendChild(cell);
      }
      
      // Function to remove stream
      function removeStream(id) {
        const cell = document.getElementById(`cell-${id}`);
        if (cell) {
          cell.remove();
        }
        
        // Stop frame capture for this broadcaster
        stopFrameCapture(id);
        
        // Clean up WebRTC connection
        if (peerConnections[id]) {
          try {
              peerConnections[id].close();
          } catch (e) {
              console.error('Error closing peer connection:', e);
          }
          delete peerConnections[id];
        }
      }
      
      // Function to clear all streams
      function clearAllStreams() {
        // Stop all frame captures
        Object.keys(captureIntervals).forEach(id => {
          stopFrameCapture(id);
        });
        
        // Close all peer connections
        Object.keys(peerConnections).forEach(id => {
          if (peerConnections[id]) {
            try {
                peerConnections[id].close();
            } catch (e) {
                console.error('Error closing peer connection during cleanup:', e);
            }
          }
        });
        
        // Reset connections map and UI
        Object.keys(peerConnections).forEach(key => delete peerConnections[key]);
        streamGrid.innerHTML = ''; // Clear UI
      }
      
      // Function to toggle video mute state
      function handleVideoMute(id) {
        const video = document.getElementById(`video-${id}`);
        const btn = event.target;
        
        if (video) {
          if (video.muted) {
            video.muted = false;
            btn.textContent = 'Mute';
            // Attempt to play if it was paused due to mute/autoplay restrictions
            video.play().catch(e => console.log('Autoplay after unmute failed:', e));
          } else {
            video.muted = true;
            btn.textContent = 'Unmute';
          }
        }
      }
      
      // Function to update debug info
      function updateDebugInfo(id, info) {
        const debugElement = document.getElementById(`debug-${id}`);
        if (debugElement) {
          debugElement.textContent = info;
        }
      }
      
      // Function to switch camera
      function switchCamera(broadcasterId) {
        console.log(`[VIEWER] Requesting camera switch for broadcaster: ${broadcasterId}`);
        
        if (!socket || !socket.connected) {
          console.error('[VIEWER] Cannot switch camera - not connected to server');
          alert('Not connected to server');
          return;
        }
        
        // Send camera switch request to server, which will forward to broadcaster
        socket.emit('switch-camera', { broadcasterId });
        
        // Update status to show request sent
        updateStreamStatus(broadcasterId, 'Switching camera...');
        updateDebugInfo(broadcasterId, 'Camera switch requested');
      }
      
      // Function to update stream status
      function updateStreamStatus(id, status) {
        const statusElement = document.getElementById(`status-${id}`);
        const indicator = document.getElementById(`indicator-${id}`);
        
        if (statusElement) {
          statusElement.textContent = status;
        }
        
        if (indicator) {
          indicator.className = 'indicator' + (status === 'Connected' ? ' connected' : '');
        }
      }
      
      // Function to update connection status
      function updateStatus(status) {
        connectionStatus.textContent = status;
      }
      
      // Function to show empty state
      function showEmptyState(message) {
        streamGrid.innerHTML = `
          <div class="empty-message">
            <p>${message}</p>
          </div>
        `;
      }
      
      // === DASHBOARD FRAME CAPTURE FUNCTIONS ===
      
      // Function to capture a frame from a video element
      function captureFrameFromVideo(broadcasterId) {
        const videoElement = document.getElementById(`video-${broadcasterId}`);
        
        if (!videoElement || videoElement.readyState < 2) {
          console.log(`[DASHBOARD] Cannot capture frame - video not ready for ${broadcasterId}`);
          return null;
        }
        
        try {
          // Create a canvas to capture the frame
          const canvas = document.createElement('canvas');
          canvas.width = videoElement.videoWidth || 640;
          canvas.height = videoElement.videoHeight || 480;
          
          const ctx = canvas.getContext('2d');
          ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
          
          // Convert to data URL (base64 image) with quality from config
          const frameDataUrl = canvas.toDataURL('image/jpeg', FRAME_QUALITY);
          
          console.log(`[DASHBOARD] Captured frame from ${broadcasterId}`);
          
          return {
            id: Date.now() + Math.random(), // Unique ID for this frame
            broadcasterId: broadcasterId,
            broadcasterName: getBroadcasterName(broadcasterId),
            timestamp: new Date().toISOString(),
            dataUrl: frameDataUrl
          };
        } catch (err) {
          console.error(`[DASHBOARD] Error capturing frame from ${broadcasterId}:`, err);
          return null;
        }
      }
      
      // Function to get broadcaster name
      function getBroadcasterName(broadcasterId) {
        const cell = document.getElementById(`cell-${broadcasterId}`);
        if (cell) {
          const nameElement = cell.querySelector('.stream-title span');
          return nameElement ? nameElement.textContent : broadcasterId;
        }
        return broadcasterId;
      }
      
      // Function to add frame to dashboard (FIFO queue)
      function addFrameToDashboard(frame) {
        if (!frame) return;
        
        // Add frame to the beginning of the array
        capturedFrames.unshift(frame);
        
        // If we exceed max frames, remove the oldest (from the end)
        if (capturedFrames.length > MAX_FRAMES) {
          capturedFrames = capturedFrames.slice(0, MAX_FRAMES);
        }
        
        console.log(`[DASHBOARD] Frame added. Total frames: ${capturedFrames.length}`);
        
        // Update the dashboard display
        updateDashboard();
      }
      
      // Function to update the dashboard display
      function updateDashboard() {
        // Update frame count
        frameCountElement.textContent = `${capturedFrames.length} / ${MAX_FRAMES} frames captured`;
        
        // Clear dashboard
        dashboardGrid.innerHTML = '';
        
        if (capturedFrames.length === 0) {
          dashboardGrid.innerHTML = `
            <div class="dashboard-empty">
              <p>No frames captured yet</p>
              <p style="font-size: 12px; margin-top: 8px;">Frames will be automatically captured from all active streams</p>
            </div>
          `;
          return;
        }
        
        // Render all frames
        capturedFrames.forEach((frame, index) => {
          const frameCard = document.createElement('div');
          frameCard.className = 'frame-card';
          
          const timeAgo = getTimeAgo(new Date(frame.timestamp));
          
          frameCard.innerHTML = `
            <img src="${frame.dataUrl}" class="frame-image" alt="Captured frame">
            <div class="frame-info">
              <div>
                <div class="frame-broadcaster">${frame.broadcasterName}</div>
                <div class="frame-timestamp">${timeAgo}</div>
              </div>
              <div style="font-size: 10px; color: #6b7280;">#${capturedFrames.length - index}</div>
            </div>
          `;
          
          dashboardGrid.appendChild(frameCard);
        });
      }
      
      // Function to get relative time string
      function getTimeAgo(date) {
        const seconds = Math.floor((new Date() - date) / 1000);
        
        if (seconds < 60) return `${seconds}s ago`;
        const minutes = Math.floor(seconds / 60);
        if (minutes < 60) return `${minutes}m ago`;
        const hours = Math.floor(minutes / 60);
        if (hours < 24) return `${hours}h ago`;
        const days = Math.floor(hours / 24);
        return `${days}d ago`;
      }
      
      // Function to start capturing frames from a broadcaster
      function startFrameCapture(broadcasterId) {
        // Don't start if already capturing
        if (captureIntervals[broadcasterId]) {
          console.log(`[DASHBOARD] Already capturing from ${broadcasterId}`);
          return;
        }
        
        console.log(`[DASHBOARD] Starting frame capture for ${broadcasterId}`);
        
        // Capture first frame immediately (after a short delay to ensure video is ready)
        setTimeout(() => {
          const frame = captureFrameFromVideo(broadcasterId);
          if (frame) addFrameToDashboard(frame);
        }, 2000);
        
        // Set up interval to capture frames periodically
        const intervalId = setInterval(() => {
          const frame = captureFrameFromVideo(broadcasterId);
          if (frame) {
            addFrameToDashboard(frame);
          }
        }, CAPTURE_INTERVAL);
        
        captureIntervals[broadcasterId] = intervalId;
      }
      
      // Function to stop capturing frames from a broadcaster
      function stopFrameCapture(broadcasterId) {
        if (captureIntervals[broadcasterId]) {
          console.log(`[DASHBOARD] Stopping frame capture for ${broadcasterId}`);
          clearInterval(captureIntervals[broadcasterId]);
          delete captureIntervals[broadcasterId];
        }
      }
      
      // Update dashboard timestamps periodically
      setInterval(() => {
        if (capturedFrames.length > 0) {
          updateDashboard();
        }
      }, 10000); // Update every 10 seconds to refresh "time ago" text
    </script>
  </body>
</html>