<!DOCTYPE html>
<html>
  <head>
    <title>Atmos Emission Monitoring System</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      body { 
        background: #0f172a; 
        color: #f8f9fa;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        margin: 0;
        padding: 0;
      }
      
      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }
      
      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      
      .btn {
        background: #4361ee;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
      }
      
      .btn:hover {
        background: #3f37c9;
      }
      
      .stream-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 15px;
        max-width: 100%;
      }
      
      .stream-cell {
        background: #1e293b;
        border-radius: 8px;
        padding: 10px;
        max-width: 450px;
      }
      
      .stream-title {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      
      video {
        width: 100%;
        max-height: 300px;
        background: #111827;
        border-radius: 4px;
        object-fit: cover;
      }
      
      .indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background-color: #ff9800;
        margin-right: 8px;
      }
      
      .indicator.connected {
        background-color: #4cc9f0;
      }
      
      .status-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        background: #374151;
        border-radius: 4px;
        margin-top: 20px;
      }
      
      .empty-message {
        text-align: center;
        padding: 40px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        grid-column: 1 / -1;
      }
      
      .stream-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        padding: 8px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 0 0 8px 8px;
      }
      
      .btn-small {
        background: #4361ee;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }
      
      .btn-small:hover {
        background: #3f37c9;
      }
      
      .btn-camera {
        background: #f72585;
      }
      
      .btn-camera:hover {
        background: #c8195f;
      }
      
      .debug-info {
        font-size: 12px;
        color: #aaa;
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      
      /* Dashboard Styles */
      .dashboard-section {
        margin-top: 30px;
        padding-top: 20px;
        border-top: 2px solid #374151;
      }
      
      .dashboard-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }
      
      .dashboard-title {
        font-size: 20px;
        font-weight: 600;
      }
      
      .frame-count {
        font-size: 14px;
        color: #9ca3af;
      }
      
      .dashboard-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 15px;
      }
      
      .frame-card {
        background: #1e293b;
        border-radius: 8px;
        padding: 10px;
        position: relative;
        overflow: hidden;
      }
      
      .frame-image {
        width: 100%;
        height: 150px;
        object-fit: cover;
        border-radius: 4px;
        background: #111827;
      }
      
      .frame-info {
        margin-top: 8px;
        font-size: 12px;
        color: #9ca3af;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .frame-broadcaster {
        font-weight: 500;
        color: #4cc9f0;
      }
      
      .frame-timestamp {
        font-size: 11px;
      }
      
      .dashboard-empty {
        text-align: center;
        padding: 40px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        color: #6b7280;
      }
      
      /* Sensor Graphs Styles */
      .sensor-graphs-section {
        margin-top: 30px;
        padding-top: 20px;
        border-top: 2px solid #374151;
      }
      
      .graphs-header {
        margin-bottom: 15px;
      }
      
      .graphs-title {
        font-size: 20px;
        font-weight: 600;
      }
      
      .graphs-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }
      
      .graph-card {
        background: #1e293b;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      
      .graph-header {
        margin-bottom: 15px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .graph-title {
        font-size: 16px;
        font-weight: 600;
        color: #f0f9ff;
      }
      
      .graph-value {
        font-size: 20px;
        font-weight: 700;
        padding: 4px 12px;
        border-radius: 6px;
      }
      
      .co2-value {
        background: rgba(239, 68, 68, 0.2);
        color: #ef4444;
      }
      
      .ch4-value {
        background: rgba(59, 130, 246, 0.2);
        color: #3b82f6;
      }
      
      .graph-canvas-container {
        position: relative;
        height: 250px;
        background: #111827;
        border-radius: 8px;
        padding: 15px;
      }
      
      /* AI Detection Results Styles */
      .detection-results {
        background: #1e293b;
        border-radius: 12px;
        padding: 20px;
        min-height: 150px;
      }
      
      .detection-empty {
        text-align: center;
        padding: 40px;
        color: #6b7280;
      }
      
      .detection-item {
        background: #111827;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 12px;
        border-left: 4px solid #3b82f6;
      }
      
      .detection-item.fire-detected {
        border-left-color: #ef4444;
        background: rgba(239, 68, 68, 0.1);
      }
      
      .detection-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      
      .detection-broadcaster {
        font-weight: 600;
        color: #f0f9ff;
      }
      
      .detection-timestamp {
        font-size: 12px;
        color: #9ca3af;
      }
      
      .detection-summary {
        display: flex;
        gap: 15px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }
      
      .detection-badge {
        display: inline-flex;
        align-items: center;
        gap: 5px;
        padding: 4px 10px;
        border-radius: 12px;
        font-size: 13px;
        font-weight: 500;
      }
      
      .detection-badge.safe {
        background: rgba(34, 197, 94, 0.2);
        color: #22c55e;
      }
      
      .detection-badge.fire {
        background: rgba(239, 68, 68, 0.2);
        color: #ef4444;
      }
      
      .detection-badge.info {
        background: rgba(59, 130, 246, 0.2);
        color: #3b82f6;
      }
      
      .detection-objects {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      
      .object-tag {
        background: rgba(139, 92, 246, 0.2);
        color: #a78bfa;
        padding: 3px 8px;
        border-radius: 8px;
        font-size: 12px;
        font-weight: 500;
      }
      
      .object-tag .confidence {
        opacity: 0.7;
        margin-left: 4px;
      }
      
      /* Environmental Data Section */
      .env-data-section {
        background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 30px;
        border: 1px solid #475569;
      }
      
      .env-data-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }
      
      .env-data-title {
        font-size: 18px;
        font-weight: 600;
        color: #f0f9ff;
      }
      
      .env-data-refresh {
        background: rgba(59, 130, 246, 0.2);
        color: #3b82f6;
        border: 1px solid #3b82f6;
        padding: 6px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s;
      }
      
      .env-data-refresh:hover {
        background: rgba(59, 130, 246, 0.3);
      }
      
      .env-data-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 15px;
      }
      
      .env-data-card {
        background: rgba(15, 23, 42, 0.6);
        border-radius: 8px;
        padding: 15px;
        border-left: 3px solid #3b82f6;
      }
      
      .env-data-card.warning {
        border-left-color: #f59e0b;
      }
      
      .env-data-card.danger {
        border-left-color: #ef4444;
      }
      
      .env-card-label {
        font-size: 12px;
        color: #9ca3af;
        margin-bottom: 5px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      
      .env-card-value {
        font-size: 24px;
        font-weight: 700;
        color: #f0f9ff;
        margin-bottom: 5px;
      }
      
      .env-card-info {
        font-size: 13px;
        color: #cbd5e1;
      }
      
      .env-data-loading {
        text-align: center;
        padding: 20px;
        color: #9ca3af;
      }
      
      .env-data-error {
        text-align: center;
        padding: 20px;
        color: #ef4444;
        background: rgba(239, 68, 68, 0.1);
        border-radius: 8px;
      }
      
      .location-info {
        font-size: 13px;
        color: #9ca3af;
        margin-top: 10px;
        display: flex;
        align-items: center;
        gap: 5px;
      }
      
      /* Detection Stack Styles */
      .detection-stack {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }
      
      .detection-stack-item {
        flex: 1;
        min-width: 300px;
        background: #111827;
        border-radius: 8px;
        padding: 15px;
        border-left: 4px solid #3b82f6;
        transition: all 0.3s ease;
      }
      
      .detection-stack-item.fire-detected {
        border-left-color: #ef4444;
        background: rgba(239, 68, 68, 0.1);
      }
      
      .detection-stack-item.latest {
        box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
      }
      
      /* Alert Modal Styles */
      .alert-modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        z-index: 9999;
        animation: fadeIn 0.3s ease;
      }
      
      .alert-modal-overlay.show {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }
      
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      
      .alert-modal {
        background: #1e293b;
        border-radius: 16px;
        max-width: 900px;
        width: 100%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        animation: slideUp 0.3s ease;
        border: 2px solid #ef4444;
      }
      
      .alert-modal.gas-alert {
        border-color: #f59e0b;
      }
      
      @keyframes slideUp {
        from { 
          transform: translateY(50px);
          opacity: 0;
        }
        to { 
          transform: translateY(0);
          opacity: 1;
        }
      }
      
      .alert-header {
        background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        padding: 20px 25px;
        border-radius: 14px 14px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .alert-header.gas-alert {
        background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      }
      
      .alert-title {
        font-size: 24px;
        font-weight: 700;
        color: white;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      
      .alert-close {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }
      
      .alert-close:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.1);
      }
      
      .alert-body {
        padding: 25px;
      }
      
      .alert-section {
        margin-bottom: 25px;
      }
      
      .alert-section-title {
        font-size: 16px;
        font-weight: 600;
        color: #f0f9ff;
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .alert-frame-container {
        position: relative;
        background: #111827;
        border-radius: 12px;
        overflow: hidden;
        border: 2px solid #374151;
      }
      
      .alert-frame-image {
        width: 100%;
        height: auto;
        display: block;
      }
      
      .alert-frame-overlay {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(239, 68, 68, 0.9);
        color: white;
        padding: 8px 12px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
      }
      
      .alert-data-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        background: #111827;
        padding: 20px;
        border-radius: 12px;
        border: 1px solid #374151;
      }
      
      .alert-data-item {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      
      .alert-data-label {
        font-size: 12px;
        color: #9ca3af;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      
      .alert-data-value {
        font-size: 22px;
        font-weight: 700;
        color: #f0f9ff;
      }
      
      .alert-data-value.danger {
        color: #ef4444;
      }
      
      .alert-data-value.warning {
        color: #f59e0b;
      }
      
      .alert-detections {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }
      
      .alert-detection-badge {
        background: rgba(239, 68, 68, 0.2);
        color: #ef4444;
        padding: 10px 16px;
        border-radius: 10px;
        font-size: 14px;
        font-weight: 600;
        border: 1px solid #ef4444;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .alert-actions {
        display: flex;
        gap: 12px;
        margin-top: 20px;
      }
      
      .alert-btn {
        flex: 1;
        padding: 12px 20px;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .alert-btn-primary {
        background: #ef4444;
        color: white;
      }
      
      .alert-btn-primary:hover {
        background: #dc2626;
        transform: translateY(-2px);
      }
      
      .alert-btn-secondary {
        background: #374151;
        color: #f0f9ff;
      }
      
      .alert-btn-secondary:hover {
        background: #4b5563;
      }
      
      .alert-timestamp {
        text-align: center;
        color: #9ca3af;
        font-size: 13px;
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid #374151;
      }
      
      .graph-canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üåç Atmos Emission Monitoring System</h1>
        <button id="connectBtn" class="btn">Connect</button>
      </div>
      
      <!-- Environmental Data Section -->
      <div class="env-data-section">
        <div class="env-data-header">
          <h2 class="env-data-title">üìç Local Environmental Data</h2>
          <button class="env-data-refresh" onclick="fetchEnvironmentalData()">üîÑ Refresh</button>
        </div>
        <div id="envDataContainer">
          <div class="env-data-loading">
            üåê Fetching location and environmental data...
          </div>
        </div>
      </div>
      
      <div id="streamGrid" class="stream-grid">
        <div class="empty-message">
          <p>No active streams</p>
          <p>Click "Connect" to find available streams</p>
        </div>
      </div>
      
      <div class="status-bar">
        <div id="connectionStatus">Not connected</div>
        <button class="btn" onclick="testAlert()" style="font-size: 12px; padding: 6px 12px;">üß™ Test Alert</button>
      </div>
      
      <!-- Dashboard Section -->
      <div class="dashboard-section">
        <div class="dashboard-header">
          <h2 class="dashboard-title">üì∏ Frame Dashboard</h2>
          <span class="frame-count" id="frameCount">0 / 10 frames captured</span>
        </div>
        <div id="dashboardGrid" class="dashboard-grid">
          <div class="dashboard-empty">
            <p>No frames captured yet</p>
            <p style="font-size: 12px; margin-top: 8px;">Frames will be automatically captured from all active streams</p>
          </div>
        </div>
      </div>
      
      <!-- Sensor Graphs Section -->
      <div class="sensor-graphs-section">
        <div class="graphs-header">
          <h2 class="graphs-title">üìä Live Sensor Data</h2>
        </div>
        <div class="graphs-container">
          <!-- CO2 Graph -->
          <div class="graph-card">
            <div class="graph-header">
              <span class="graph-title">CO‚ÇÇ Concentration</span>
              <span class="graph-value co2-value" id="co2CurrentValue">0 ppm</span>
            </div>
            <div class="graph-canvas-container">
              <canvas id="co2Graph" class="graph-canvas"></canvas>
            </div>
          </div>
          
          <!-- CH4 Graph -->
          <div class="graph-card">
            <div class="graph-header">
              <span class="graph-title">CH‚ÇÑ Concentration</span>
              <span class="graph-value ch4-value" id="ch4CurrentValue">0 ppm</span>
            </div>
            <div class="graph-canvas-container">
              <canvas id="ch4Graph" class="graph-canvas"></canvas>
            </div>
          </div>
        </div>
      </div>
      
      <!-- AI Detection Results Section -->
      <div class="sensor-graphs-section">
        <div class="graphs-header">
          <h2 class="graphs-title">üîç AI Detection Results (YOLOv8n)</h2>
          <p style="font-size: 13px; color: #9ca3af; margin-top: 5px;">Latest 3 predictions ‚Ä¢ Updates every 3 seconds</p>
        </div>
        <div id="detectionResults" class="detection-results">
          <div class="detection-empty">
            <p>ü§ñ Waiting for frames to analyze...</p>
            <p style="font-size: 12px; color: #6b7280; margin-top: 8px;">Frames are analyzed every 3 seconds for fire, smoke, and other objects</p>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Alert Modal -->
    <div id="alertModal" class="alert-modal-overlay">
      <div id="alertModalContent" class="alert-modal">
        <!-- Modal content will be dynamically inserted here -->
      </div>
    </div>
    
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script src="config.js"></script>
    <script>
      // Use configuration from config.js
      const CONFIG = window.ATMOS_CONFIG || {
        getServerUrl: () => 'http://localhost:3001',
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
        dashboard: { maxFrames: 10, captureInterval: 3000, frameQuality: 0.8 },
        socketConfig: { transports: ['websocket', 'polling'] },
        debug: false
      };
      
      let socket;
      const peerConnections = {}; // Map of broadcasterId -> RTCPeerConnection
      const streamGrid = document.getElementById('streamGrid');
      const connectBtn = document.getElementById('connectBtn');
      const connectionStatus = document.getElementById('connectionStatus');
      
      // Dashboard frame management (from config)
      const MAX_FRAMES = CONFIG.dashboard.maxFrames;
      const CAPTURE_INTERVAL = CONFIG.dashboard.captureInterval;
      const FRAME_QUALITY = CONFIG.dashboard.frameQuality;
      let capturedFrames = []; // Array to store frames (FIFO queue)
      let captureIntervals = {}; // Map of broadcasterId -> interval ID
      const dashboardGrid = document.getElementById('dashboardGrid');
      const frameCountElement = document.getElementById('frameCount');
      
      // === SENSOR DATA & GRAPHING ===
      
      // Sensor data storage
      const sensorData = {
        co2: [],
        ch4: [],
        timestamps: []
      };
      
      const MAX_DATA_POINTS = 50; // Show last 50 data points on graph
      
      // Canvas elements and contexts
      let co2Canvas, ch4Canvas;
      let co2Ctx, ch4Ctx;
      
      // Initialize canvases when DOM is ready
      window.addEventListener('DOMContentLoaded', () => {
        co2Canvas = document.getElementById('co2Graph');
        ch4Canvas = document.getElementById('ch4Graph');
        
        if (co2Canvas && ch4Canvas) {
          co2Ctx = co2Canvas.getContext('2d');
          ch4Ctx = ch4Canvas.getContext('2d');
          
          // Set canvas size to match container
          resizeCanvas(co2Canvas);
          resizeCanvas(ch4Canvas);
          
          // Initial draw
          drawGraph(co2Ctx, co2Canvas, sensorData.co2, sensorData.timestamps, '#ef4444', 'CO‚ÇÇ (ppm)');
          drawGraph(ch4Ctx, ch4Canvas, sensorData.ch4, sensorData.timestamps, '#3b82f6', 'CH‚ÇÑ (ppm)');
        }
      });
      
      // Resize canvas to match container
      function resizeCanvas(canvas) {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth - 30;
        canvas.height = container.clientHeight - 30;
      }
      
      // Generate random sensor data with normal distribution (bell curve)
      // Uses Box-Muller transform for normal distribution
      function generateNormalRandom(mean, stdDev) {
        let u1 = Math.random();
        let u2 = Math.random();
        let z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
        return Math.max(0, Math.round(mean + z0 * stdDev)); // Ensure non-negative
      }
      
      function generateSensorData() {
        // CO‚ÇÇ: Normal distribution centered at 900 ppm, stdDev 900
        // This gives more frequent spikes above 1500 ppm for testing
        const co2 = generateNormalRandom(900, 900);
        
        // CH‚ÇÑ: Normal distribution centered at 50 ppm, stdDev 1000
        // Most values near 50, rarely exceeds 5000
        const ch4 = generateNormalRandom(50, 1000);
        
        return { co2, ch4 };
      }
      
      // Add sensor data point
      function addSensorDataPoint(co2, ch4) {
        const now = new Date();
        const timeString = now.toLocaleTimeString('en-US', { 
          hour12: false, 
          hour: '2-digit', 
          minute: '2-digit', 
          second: '2-digit' 
        });
        
        // Add new data
        sensorData.co2.push(co2);
        sensorData.ch4.push(ch4);
        sensorData.timestamps.push(timeString);
        
        // Keep only last MAX_DATA_POINTS
        if (sensorData.co2.length > MAX_DATA_POINTS) {
          sensorData.co2.shift();
          sensorData.ch4.shift();
          sensorData.timestamps.shift();
        }
        
        // Update current value displays
        document.getElementById('co2CurrentValue').textContent = `${co2} ppm`;
        document.getElementById('ch4CurrentValue').textContent = `${ch4} ppm`;
        
        // Check thresholds and raise alerts
        checkGasThresholds(co2, ch4, timeString);
        
        // Redraw graphs
        drawGraph(co2Ctx, co2Canvas, sensorData.co2, sensorData.timestamps, '#ef4444', 'CO‚ÇÇ (ppm)');
        drawGraph(ch4Ctx, ch4Canvas, sensorData.ch4, sensorData.timestamps, '#3b82f6', 'CH‚ÇÑ (ppm)');
        
        console.log(`[SENSOR] CO‚ÇÇ: ${co2} ppm, CH‚ÇÑ: ${ch4} ppm`);
      }
      
      // === ALERT SYSTEM ===
      
      const ALERT_THRESHOLDS = {
        co2: 1500,  // 1500 ppm (lowered for better detection)
        ch4: 5000   // 5000 ppm
      };
      
      // Track last alert times to avoid spam
      const lastAlerts = {
        co2: {},  // {broadcasterId: timestamp}
        ch4: {}   // {broadcasterId: timestamp}
      };
      
      const ALERT_COOLDOWN = 30000; // 30 seconds between same alerts
      
      // Check gas thresholds and raise alerts
      function checkGasThresholds(co2, ch4, timeString) {
        const now = Date.now();
        
        // Get current broadcaster ID (from the frame that triggered this)
        const broadcasterId = window.currentBroadcasterId || 'Unknown';
        
        console.log(`[THRESHOLD CHECK] CO‚ÇÇ: ${co2}, CH‚ÇÑ: ${ch4}, Broadcaster: ${broadcasterId}`);
        
        // Check CO‚ÇÇ threshold
        if (co2 > ALERT_THRESHOLDS.co2) {
          console.log(`[ALERT TRIGGERED] CO‚ÇÇ threshold exceeded: ${co2} > ${ALERT_THRESHOLDS.co2}`);
          const lastAlert = lastAlerts.co2[broadcasterId] || 0;
          if (now - lastAlert > ALERT_COOLDOWN) {
            raiseGasAlert('CO‚ÇÇ', co2, ALERT_THRESHOLDS.co2, broadcasterId, timeString);
            lastAlerts.co2[broadcasterId] = now;
          } else {
            console.log(`[ALERT SKIPPED] CO‚ÇÇ alert on cooldown (${Math.round((ALERT_COOLDOWN - (now - lastAlert)) / 1000)}s remaining)`);
          }
        }
        
        // Check CH‚ÇÑ threshold
        if (ch4 > ALERT_THRESHOLDS.ch4) {
          console.log(`[ALERT TRIGGERED] CH‚ÇÑ threshold exceeded: ${ch4} > ${ALERT_THRESHOLDS.ch4}`);
          const lastAlert = lastAlerts.ch4[broadcasterId] || 0;
          if (now - lastAlert > ALERT_COOLDOWN) {
            raiseGasAlert('CH‚ÇÑ', ch4, ALERT_THRESHOLDS.ch4, broadcasterId, timeString);
            lastAlerts.ch4[broadcasterId] = now;
          } else {
            console.log(`[ALERT SKIPPED] CH‚ÇÑ alert on cooldown (${Math.round((ALERT_COOLDOWN - (now - lastAlert)) / 1000)}s remaining)`);
          }
        }
      }
      
      // Raise gas threshold alert
      function raiseGasAlert(gasType, value, threshold, broadcasterId, timeString) {
        console.error(`[ALERT] ${gasType} THRESHOLD EXCEEDED!`, {
          monitor: broadcasterId,
          value: value,
          threshold: threshold,
          time: timeString
        });
        
        // Get current sensor data
        const co2Current = sensorData.co2.length > 0 ? sensorData.co2[sensorData.co2.length - 1] : 0;
        const ch4Current = sensorData.ch4.length > 0 ? sensorData.ch4[sensorData.ch4.length - 1] : 0;
        
        // Find the latest frame from this broadcaster
        const latestFrame = capturedFrames.find(f => f.broadcasterId === broadcasterId);
        
        showAlertModal({
          type: 'gas',
          gasType: gasType,
          value: value,
          threshold: threshold,
          broadcasterId: broadcasterId,
          timestamp: timeString,
          frameDataUrl: latestFrame ? latestFrame.dataUrl : null,
          sensorData: {
            co2: co2Current,
            ch4: ch4Current
          }
        });
      }
      
      // Raise fire/smoke detection alert
      function raiseFireAlert(broadcasterId, detections, frameDataUrl) {
        console.error(`[ALERT] FIRE/SMOKE DETECTED!`, {
          monitor: broadcasterId,
          detections: detections
        });
        
        // Get current sensor data
        const co2Current = sensorData.co2.length > 0 ? sensorData.co2[sensorData.co2.length - 1] : 0;
        const ch4Current = sensorData.ch4.length > 0 ? sensorData.ch4[sensorData.ch4.length - 1] : 0;
        
        showAlertModal({
          type: 'fire',
          broadcasterId: broadcasterId,
          detections: detections,
          frameDataUrl: frameDataUrl,
          timestamp: new Date().toLocaleString(),
          sensorData: {
            co2: co2Current,
            ch4: ch4Current
          }
        });
      }
      
      // Show Alert Modal with all data
      function showAlertModal(alertData) {
        console.log('[ALERT MODAL] showAlertModal called with:', alertData);
        
        const modal = document.getElementById('alertModal');
        const modalContent = document.getElementById('alertModalContent');
        
        console.log('[ALERT MODAL] Modal element:', modal);
        console.log('[ALERT MODAL] Modal content element:', modalContent);
        
        const isFire = alertData.type === 'fire';
        const isGas = alertData.type === 'gas';
        
        let html = `
          <div class="alert-header ${isGas ? 'gas-alert' : ''}">
            <div class="alert-title">
              ${isFire ? 'üî• FIRE/SMOKE DETECTED!' : 'üö® GAS ALERT!'}
            </div>
            <button class="alert-close" onclick="closeAlertModal()">‚úï</button>
          </div>
          <div class="alert-body">
        `;
        
        // Frame section
        if (alertData.frameDataUrl) {
          html += `
            <div class="alert-section">
              <div class="alert-section-title">üì∏ Captured Frame</div>
              <div class="alert-frame-container">
                <img src="${alertData.frameDataUrl}" class="alert-frame-image" alt="Alert Frame">
                <div class="alert-frame-overlay">
                  ${isFire ? 'üî• FIRE DETECTED' : 'üö® ALERT'}
                </div>
              </div>
            </div>
          `;
        }
        
        // Detection details for fire alerts
        if (isFire && alertData.detections) {
          html += `
            <div class="alert-section">
              <div class="alert-section-title">üéØ Detections</div>
              <div class="alert-detections">
          `;
          alertData.detections.forEach(det => {
            const confidence = (det.confidence * 100).toFixed(1);
            const emoji = det.class.toLowerCase().includes('fire') ? 'üî•' : 
                         det.class.toLowerCase().includes('smoke') ? 'üí®' : '‚ö†Ô∏è';
            html += `
              <div class="alert-detection-badge">
                ${emoji} ${det.class} <strong>${confidence}%</strong>
              </div>
            `;
          });
          html += `
              </div>
            </div>
          `;
        }
        
        // Alert details
        html += `
          <div class="alert-section">
            <div class="alert-section-title">üìä Alert Details</div>
            <div class="alert-data-grid">
              <div class="alert-data-item">
                <div class="alert-data-label">Monitor ID</div>
                <div class="alert-data-value">${alertData.broadcasterId}</div>
              </div>
              <div class="alert-data-item">
                <div class="alert-data-label">Time</div>
                <div class="alert-data-value">${alertData.timestamp}</div>
              </div>
        `;
        
        if (isGas) {
          html += `
              <div class="alert-data-item">
                <div class="alert-data-label">Gas Type</div>
                <div class="alert-data-value danger">${alertData.gasType}</div>
              </div>
              <div class="alert-data-item">
                <div class="alert-data-label">Current Value</div>
                <div class="alert-data-value danger">${alertData.value} ppm</div>
              </div>
              <div class="alert-data-item">
                <div class="alert-data-label">Threshold</div>
                <div class="alert-data-value warning">${alertData.threshold} ppm</div>
              </div>
              <div class="alert-data-item">
                <div class="alert-data-label">Exceeded By</div>
                <div class="alert-data-value danger">${(alertData.value - alertData.threshold)} ppm</div>
              </div>
          `;
        }
        
        html += `
            </div>
          </div>
        `;
        
        // Current sensor readings
        if (alertData.sensorData) {
          html += `
            <div class="alert-section">
              <div class="alert-section-title">üå°Ô∏è Current Sensor Readings</div>
              <div class="alert-data-grid">
                <div class="alert-data-item">
                  <div class="alert-data-label">CO‚ÇÇ Concentration</div>
                  <div class="alert-data-value ${alertData.sensorData.co2 > ALERT_THRESHOLDS.co2 ? 'danger' : ''}">${alertData.sensorData.co2} ppm</div>
                </div>
                <div class="alert-data-item">
                  <div class="alert-data-label">CH‚ÇÑ Concentration</div>
                  <div class="alert-data-value ${alertData.sensorData.ch4 > ALERT_THRESHOLDS.ch4 ? 'danger' : ''}">${alertData.sensorData.ch4} ppm</div>
                </div>
              </div>
            </div>
          `;
        }
        
        // Action buttons
        html += `
            <div class="alert-actions">
              <button class="alert-btn alert-btn-primary" onclick="acknowledgeAlert()">
                ‚úì Acknowledge Alert
              </button>
              <button class="alert-btn alert-btn-secondary" onclick="downloadAlertData()">
                üíæ Download Report
              </button>
            </div>
            <div class="alert-timestamp">
              Alert triggered at ${new Date().toLocaleString()}
            </div>
          </div>
        `;
        
        modalContent.innerHTML = html;
        modalContent.className = `alert-modal ${isGas ? 'gas-alert' : ''}`;
        modal.classList.add('show');
        
        console.log('[ALERT MODAL] Modal classes:', modal.className);
        console.log('[ALERT MODAL] Modal should now be visible!');
        
        // Store alert data for download
        window.currentAlertData = alertData;
        
        // Play alert sound (optional - you can add audio element)
        playAlertSound();
      }
      
      // Close alert modal
      function closeAlertModal() {
        const modal = document.getElementById('alertModal');
        modal.classList.remove('show');
      }
      
      // Acknowledge alert
      function acknowledgeAlert() {
        console.log('[ALERT] Alert acknowledged by user');
        closeAlertModal();
      }
      
      // Download alert data as JSON
      function downloadAlertData() {
        const data = window.currentAlertData;
        if (!data) return;
        
        const report = {
          alertType: data.type,
          timestamp: new Date().toISOString(),
          broadcasterId: data.broadcasterId,
          details: data,
          sensorReadings: data.sensorData
        };
        
        const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `alert_${data.type}_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        console.log('[ALERT] Alert data downloaded');
      }
      
      // Play alert sound
      function playAlertSound() {
        // Create a simple beep sound using Web Audio API
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          oscillator.frequency.value = 800; // Hz
          oscillator.type = 'sine';
          
          gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
          
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.5);
        } catch (e) {
          console.log('[ALERT] Could not play sound:', e);
        }
      }
      
      // Close modal when clicking outside
      document.addEventListener('click', (e) => {
        const modal = document.getElementById('alertModal');
        if (e.target === modal) {
          closeAlertModal();
        }
      });
      
      // Test alert function (for debugging)
      function testAlert() {
        const testType = Math.random() > 0.5 ? 'fire' : 'gas';
        
        if (testType === 'fire') {
          // Test fire alert
          raiseFireAlert(
            'Test_Monitor_001',
            [
              { class: 'fire', confidence: 0.95, bbox: [100, 200, 300, 400] },
              { class: 'smoke', confidence: 0.87, bbox: [150, 250, 350, 450] }
            ],
            'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQwIiBoZWlnaHQ9IjQ4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iNjQwIiBoZWlnaHQ9IjQ4MCIgZmlsbD0iIzMzMyIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiNmZmYiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiPvCflqXvuI8gVEVTVCBGUkFNRTwvdGV4dD48L3N2Zz4='
          );
        } else {
          // Test gas alert
          raiseGasAlert('CO‚ÇÇ', 2500, ALERT_THRESHOLDS.co2, 'Test_Monitor_001', new Date().toLocaleTimeString());
        }
        
        console.log(`[TEST] Triggered ${testType} alert`);
      }

      
      // Draw graph on canvas
      function drawGraph(ctx, canvas, data, timestamps, color, label) {
        const width = canvas.width;
        const height = canvas.height;
        const padding = 40;
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        if (data.length === 0) {
          // Show "No data" message
          ctx.fillStyle = '#6b7280';
          ctx.font = '14px system-ui';
          ctx.textAlign = 'center';
          ctx.fillText('Waiting for data...', width / 2, height / 2);
          return;
        }
        
        // Calculate min and max for scaling
        const minValue = Math.min(...data);
        const maxValue = Math.max(...data);
        const range = maxValue - minValue || 1; // Avoid division by zero
        
        // Draw axes
        ctx.strokeStyle = '#374151';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, height - padding);
        ctx.lineTo(width - padding, height - padding);
        ctx.stroke();
        
        // Draw grid lines
        ctx.strokeStyle = '#1f2937';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 5; i++) {
          const y = padding + (height - 2 * padding) * i / 5;
          ctx.beginPath();
          ctx.moveTo(padding, y);
          ctx.lineTo(width - padding, y);
          ctx.stroke();
        }
        
        // Draw Y-axis labels
        ctx.fillStyle = '#9ca3af';
        ctx.font = '11px system-ui';
        ctx.textAlign = 'right';
        for (let i = 0; i <= 5; i++) {
          const value = maxValue - (range * i / 5);
          const y = padding + (height - 2 * padding) * i / 5;
          ctx.fillText(Math.round(value), padding - 5, y + 4);
        }
        
        // Draw data line
        if (data.length > 1) {
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          
          const xStep = (width - 2 * padding) / (Math.max(data.length - 1, 1));
          
          for (let i = 0; i < data.length; i++) {
            const x = padding + i * xStep;
            const normalizedValue = (data[i] - minValue) / range;
            const y = height - padding - normalizedValue * (height - 2 * padding);
            
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          
          ctx.stroke();
          
          // Draw data points
          ctx.fillStyle = color;
          for (let i = 0; i < data.length; i++) {
            const x = padding + i * xStep;
            const normalizedValue = (data[i] - minValue) / range;
            const y = height - padding - normalizedValue * (height - 2 * padding);
            
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, 2 * Math.PI);
            ctx.fill();
          }
        }
        
        // Draw X-axis labels (show every 5th timestamp to avoid crowding)
        ctx.fillStyle = '#9ca3af';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'center';
        const labelStep = Math.max(1, Math.floor(timestamps.length / 10));
        for (let i = 0; i < timestamps.length; i += labelStep) {
          const x = padding + i * ((width - 2 * padding) / (Math.max(data.length - 1, 1)));
          ctx.fillText(timestamps[i], x, height - padding + 15);
        }
      }
      
      // Set up connect button
      connectBtn.addEventListener('click', connectToServer);
      
      // Function to connect to the server
      function connectToServer() {
        updateStatus('Connecting...');
        
        // Use configuration to get server URL
        const serverUrl = CONFIG.getServerUrl();
        
        if (CONFIG.debug) {
          console.log('[VIEWER] üîå Connecting to server...');
          console.log('[VIEWER] ÔøΩ Server URL:', serverUrl);
          console.log('[VIEWER] üåç Environment:', CONFIG.environment);
        }
        
        console.log(`[VIEWER] ‚úì Connecting to: ${serverUrl}`);
        
        // Close any existing connection
        if (socket) {
          socket.disconnect();
        }
        
        // Connect to the server with configuration
        socket = io(serverUrl, CONFIG.socketConfig);
        
        // Set up socket event handlers
        socket.on('connect', () => {
          updateStatus('Connected');
          socket.emit('list-broadcasters');
        });
        
        socket.on('connect_error', (error) => {
          updateStatus(`Connection error: ${error.message}`);
          showEmptyState(`Connection error: ${error.message}<br>Check server status and network.`);
        });
        
        socket.on('disconnect', () => {
          updateStatus('Disconnected');
          clearAllStreams();
          showEmptyState('Disconnected from server<br>Click "Connect" to reconnect');
        });
        
        // Handle broadcaster list
        socket.on('broadcaster-list', (broadcasters) => {
          if (broadcasters.length === 0) {
            showEmptyState('No active streams found');
            return;
          }
          
          streamGrid.innerHTML = '';
          
          // Create stream cell for each broadcaster
          broadcasters.forEach(broadcaster => {
            createStreamCell(broadcaster.id, broadcaster.name || `Stream ${broadcaster.monitorNumber}`);
            socket.emit('connect-to-broadcaster', broadcaster.id);
          });
        });
        
        // Handle new broadcaster
        socket.on('broadcaster-joined', (broadcaster) => {
          if (!document.getElementById(`cell-${broadcaster.id}`)) {
            createStreamCell(broadcaster.id, broadcaster.name || `Stream ${broadcaster.monitorNumber}`);
            socket.emit('connect-to-broadcaster', broadcaster.id);
          }
        });
        
        // Handle broadcaster disconnection
        socket.on('broadcaster-disconnected', (broadcasterId) => {
          removeStream(broadcasterId);
          
          if (streamGrid.children.length === 0 || 
              (streamGrid.children.length === 1 && streamGrid.children[0].classList.contains('empty-message'))) {
            showEmptyState('No active streams found');
          }
        });
        
        // Handle WebRTC offer from broadcaster
        socket.on('offer', async (data) => {
          try {
            console.log('[OFFER] Received offer from broadcaster', {
              data,
              broadcasterId: data.broadcasterId,
              hasSdp: !!data.sdp,
              sdpType: typeof data.sdp,
              existingPeerConnections: Object.keys(peerConnections)
            });
            
            const broadcasterId = data.broadcasterId || 
                                (typeof data.target === 'string' ? data.target : null);
            
            if (!broadcasterId) {
              console.error('[OFFER] Invalid offer: missing broadcasterId');
              return;
            }
            
            console.log(`[OFFER] Processing for broadcaster: ${broadcasterId}`);
            
            if (!peerConnections[broadcasterId]) {
              console.log(`[OFFER] No existing peer connection, creating new one for ${broadcasterId}`);
              const newPc = setupPeerConnection(broadcasterId);
              if (!newPc) {
                console.error(`[OFFER] Failed to create peer connection for ${broadcasterId}`);
                return;
              }
              
              // Stream cell should already exist from broadcaster-list or broadcaster-joined
              if (!document.getElementById(`cell-${broadcasterId}`)) {
                console.warn(`[OFFER] No stream cell exists for ${broadcasterId} - creating one now`);
                // Create cell as fallback (shouldn't normally happen)
                createStreamCell(broadcasterId, 'Stream'); 
              } else {
                console.log(`[OFFER] Stream cell already exists for ${broadcasterId}`);
              }
            }
            
            const pc = peerConnections[broadcasterId];
            if (!pc) {
              console.error(`[OFFER] No valid peer connection for ${broadcasterId}`);
              return;
            }
            
            console.log(`[OFFER] Peer connection state: ${pc.signalingState}, ice: ${pc.iceConnectionState}`);
            
            // FIX: Robustly extract SDP from the signaling data
            let sdpToUse;
            console.log('[OFFER] Extracting SDP, raw data.sdp:', data.sdp);
            
            if (data.sdp && data.sdp.sdp && data.sdp.type) {
                // Case 1: Full RTCSessionDescription object
                sdpToUse = { type: data.sdp.type, sdp: data.sdp.sdp };
                console.log('[OFFER] Case 1: Full RTCSessionDescription');
            } else if (data.sdp && typeof data.sdp === 'object' && !data.sdp.type) {
                // Case 2: Broadcaster sent the RTCSessionDescription object without type field (handled by server)
                sdpToUse = { type: 'offer', sdp: data.sdp.sdp || data.sdp };
                console.log('[OFFER] Case 2: Object without type field');
            } else if (typeof data.sdp === 'string') {
                // Case 3: Raw SDP string
                sdpToUse = { type: 'offer', sdp: data.sdp };
                console.log('[OFFER] Case 3: Raw SDP string');
            } else {
                console.error('[OFFER] Invalid SDP format received:', data);
                return;
            }
            
            console.log('[OFFER] SDP to use:', { type: sdpToUse.type, sdpLength: sdpToUse.sdp?.length });
            
            // Set remote description
            let answer;
            try {
              console.log(`[OFFER] Setting remote description for ${broadcasterId}`, { type: sdpToUse.type, sdpLength: sdpToUse.sdp?.length });
              await pc.setRemoteDescription(new RTCSessionDescription(sdpToUse));
              console.log(`[OFFER] Remote description set successfully for ${broadcasterId}`);
              
              // Create and send answer
              console.log(`[OFFER] Creating answer for ${broadcasterId}`);
              answer = await pc.createAnswer();
              console.log(`[OFFER] Answer created for ${broadcasterId}`, { type: answer.type, sdpLength: answer.sdp?.length });
              
              await pc.setLocalDescription(answer);
              console.log(`[OFFER] Local description set for ${broadcasterId}`);
              
              updateStreamStatus(broadcasterId, 'Connecting...');
              console.log(`[OFFER] Status updated to Connecting for ${broadcasterId}`);
            } catch (sdpError) {
              console.error(`[OFFER] Error during SDP handling for ${broadcasterId}:`, sdpError);

              console.error(`Error in SDP handling for ${broadcasterId}:`, sdpError);
              updateStreamStatus(broadcasterId, `Connection error: ${sdpError.name}`);
              return;
            }
            
            // Send the answer back to the broadcaster via the signaling server
            socket.emit('answer', {
              sdp: answer,
              targetBroadcasterId: broadcasterId
            });
            
            console.log(`Sent answer to broadcaster ${broadcasterId}`);
            updateStreamStatus(broadcasterId, 'Connecting');
          } catch (err) {
            console.error('Error handling offer:', err);
            updateStreamStatus(broadcasterId, `Offer error: ${err.message}`);
          }
        });
        
        // Handle ICE candidates from broadcaster
        socket.on('ice-candidate', async (data) => {
          try {
            const broadcasterId = data.broadcasterId || data.from;

            if (!broadcasterId || !peerConnections[broadcasterId]) return;
            
            // Add ICE candidate to the connection
            // The candidate object needs to be a valid RTCIceCandidate
            if (data.candidate) {
                await peerConnections[broadcasterId].addIceCandidate(
                    new RTCIceCandidate(data.candidate)
                );
            }
          } catch (err) {
            console.error('Error adding ICE candidate:', err);
          }
        });
        
        // Frame handler removed - using WebRTC video stream instead
      }
      
      // Function to setup WebRTC peer connection
      function setupPeerConnection(broadcasterId) {
        console.log(`Setting up peer connection for broadcaster: ${broadcasterId}`);
        
        try {
          // Create peer connection with STUN servers from config
          const pc = new RTCPeerConnection({
            iceServers: CONFIG.iceServers
          });
        
        peerConnections[broadcasterId] = pc;
        
        // Handle incoming tracks (video/audio)
        pc.ontrack = (event) => {
          console.log(`[ONTRACK] Received track from ${broadcasterId}`, {
            kind: event.track.kind,
            enabled: event.track.enabled,
            readyState: event.track.readyState,
            muted: event.track.muted,
            streamCount: event.streams?.length,
            streamId: event.streams[0]?.id
          });
          
          // Update debug info with track details
          updateDebugInfo(broadcasterId, `Track: ${event.track.kind}, enabled: ${event.track.enabled}`);
          
          const videoElement = document.getElementById(`video-${broadcasterId}`);
          console.log(`[ONTRACK] Video element for ${broadcasterId}:`, {
            exists: !!videoElement,
            currentSrc: videoElement?.srcObject?.id,
            newSrc: event.streams[0]?.id
          });
          
          if (videoElement) {
            // Check if the stream is already set
            if (videoElement.srcObject === event.streams[0]) {
                console.log(`[ONTRACK] Stream already set on video element for ${broadcasterId}. Skipping update.`);
                return;
            }
            
            console.log(`[ONTRACK] Setting video stream for ${broadcasterId}`, {
              hasStreams: !!event.streams,
              streamCount: event.streams?.length,
              stream0: event.streams[0]
            });
            
            if (event.streams && event.streams[0]) {
              
              // Set stream
              videoElement.srcObject = event.streams[0];
              console.log(`[ONTRACK] srcObject set for ${broadcasterId}`);
              
              // Monitor video element events
              videoElement.onloadedmetadata = () => {
                console.log(`[ONTRACK] Video metadata loaded for ${broadcasterId}`, {
                  videoWidth: videoElement.videoWidth,
                  videoHeight: videoElement.videoHeight,
                  duration: videoElement.duration,
                  readyState: videoElement.readyState
                });
                
                updateDebugInfo(broadcasterId, 
                  `Video: ${videoElement.videoWidth}x${videoElement.videoHeight}`);
                  
                // Attempt to play the video (it's muted, so it should play)
                videoElement.play()
                  .then(() => {
                    console.log(`[ONTRACK] Video playback started for ${broadcasterId}`);
                    updateStreamStatus(broadcasterId, 'Connected');
                  })
                  .catch(e => console.error(`[ONTRACK] Error playing video for ${broadcasterId}:`, e));
              };
              
              videoElement.onerror = (e) => {
                console.error(`[ONTRACK] Video element error for ${broadcasterId}:`, e, videoElement.error);
              };
            } else {
              console.error(`[ONTRACK] No streams in track event for ${broadcasterId}`);

              console.warn("Received empty stream array or null stream");
            }
            
            // Additional video element event listeners
            videoElement.onwaiting = () => {
              console.log(`Video waiting for data: ${broadcasterId}`);
              updateStreamStatus(broadcasterId, 'Buffering...');
            };
            
            videoElement.onplaying = () => {
              console.log(`Video playing: ${broadcasterId}`);
              updateStreamStatus(broadcasterId, 'Connected');
              
              // Start capturing frames for dashboard when video starts playing
              startFrameCapture(broadcasterId);
            };
            
            updateStreamStatus(broadcasterId, 'Connected');
          }
        };
        
        // Handle connection state changes
        pc.onconnectionstatechange = () => {
          console.log(`Connection state changed for ${broadcasterId}: ${pc.connectionState}`);
          
          if (pc.connectionState === 'connected') {
            updateStreamStatus(broadcasterId, 'Connected');
          } else if (pc.connectionState === 'disconnected' || 
              pc.connectionState === 'failed' || 
              pc.connectionState === 'closed') {
            updateStreamStatus(broadcasterId, 'Disconnected');
            console.log(`Connection lost with ${broadcasterId}`);
          }
        };
        
        // Log ICE connection state changes
        pc.oniceconnectionstatechange = () => {
          console.log(`ICE connection state for ${broadcasterId}: ${pc.iceConnectionState}`);
        };
        
        // Handle ICE candidates
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            socket.emit('ice-candidate', {
              candidate: event.candidate,
              targetBroadcasterId: broadcasterId
            });
          }
        };
        
        return pc;
        } catch (error) {
          console.error(`Error setting up peer connection: ${error.message}`);
          updateStatus(`Connection error: ${error.message}`);
          return null;
        }
      }
      
      // Function to create stream cell in the grid
      function createStreamCell(id, name) {
        const existingCell = document.getElementById(`cell-${id}`);
        if (existingCell) {
            console.warn(`Stream cell for ${id} already exists.`);
            // Update the name just in case
            const nameElement = existingCell.querySelector('.stream-title span:not(.debug-info)');
            if (nameElement) nameElement.textContent = name;
            return;
        }
        
        // Remove empty message if present
        const emptyMessage = streamGrid.querySelector('.empty-message');
        if (emptyMessage) {
            streamGrid.innerHTML = '';
        }

        const cell = document.createElement('div');
        cell.className = 'stream-cell';
        cell.id = `cell-${id}`;
        
        cell.innerHTML = `
          <div class="stream-title">
            <div style="display: flex; align-items: center;">
              <div class="indicator" id="indicator-${id}"></div>
              <span>${name}</span>
            </div>
            <span id="status-${id}">Waiting...</span>
          </div>
          <video id="video-${id}" autoplay playsinline controls muted
            style="width: 100%; height: 100%; background-color: #000; display: block; object-fit: cover;"></video>
          <div class="stream-controls">
            <button class="btn-small" onclick="handleVideoMute('${id}')">Unmute</button>
            <button class="btn-small btn-camera" onclick="switchCamera('${id}')">üì∑ Switch Camera</button>
            <div class="debug-info" id="debug-${id}"></div>
          </div>
        `;
        
        streamGrid.appendChild(cell);
      }
      
      // Function to remove stream
      function removeStream(id) {
        const cell = document.getElementById(`cell-${id}`);
        if (cell) {
          cell.remove();
        }
        
        // Stop frame capture for this broadcaster
        stopFrameCapture(id);
        
        // Clean up WebRTC connection
        if (peerConnections[id]) {
          try {
              peerConnections[id].close();
          } catch (e) {
              console.error('Error closing peer connection:', e);
          }
          delete peerConnections[id];
        }
      }
      
      // Function to clear all streams
      function clearAllStreams() {
        // Stop all frame captures
        Object.keys(captureIntervals).forEach(id => {
          stopFrameCapture(id);
        });
        
        // Close all peer connections
        Object.keys(peerConnections).forEach(id => {
          if (peerConnections[id]) {
            try {
                peerConnections[id].close();
            } catch (e) {
                console.error('Error closing peer connection during cleanup:', e);
            }
          }
        });
        
        // Reset connections map and UI
        Object.keys(peerConnections).forEach(key => delete peerConnections[key]);
        streamGrid.innerHTML = ''; // Clear UI
      }
      
      // Function to toggle video mute state
      function handleVideoMute(id) {
        const video = document.getElementById(`video-${id}`);
        const btn = event.target;
        
        if (video) {
          if (video.muted) {
            video.muted = false;
            btn.textContent = 'Mute';
            // Attempt to play if it was paused due to mute/autoplay restrictions
            video.play().catch(e => console.log('Autoplay after unmute failed:', e));
          } else {
            video.muted = true;
            btn.textContent = 'Unmute';
          }
        }
      }
      
      // Function to update debug info
      function updateDebugInfo(id, info) {
        const debugElement = document.getElementById(`debug-${id}`);
        if (debugElement) {
          debugElement.textContent = info;
        }
      }
      
      // Function to switch camera
      function switchCamera(broadcasterId) {
        console.log(`[VIEWER] Requesting camera switch for broadcaster: ${broadcasterId}`);
        
        if (!socket || !socket.connected) {
          console.error('[VIEWER] Cannot switch camera - not connected to server');
          alert('Not connected to server');
          return;
        }
        
        // Send camera switch request to server, which will forward to broadcaster
        socket.emit('switch-camera', { broadcasterId });
        
        // Update status to show request sent
        updateStreamStatus(broadcasterId, 'Switching camera...');
        updateDebugInfo(broadcasterId, 'Camera switch requested');
      }
      
      // Function to update stream status
      function updateStreamStatus(id, status) {
        const statusElement = document.getElementById(`status-${id}`);
        const indicator = document.getElementById(`indicator-${id}`);
        
        if (statusElement) {
          statusElement.textContent = status;
        }
        
        if (indicator) {
          indicator.className = 'indicator' + (status === 'Connected' ? ' connected' : '');
        }
      }
      
      // Function to update connection status
      function updateStatus(status) {
        connectionStatus.textContent = status;
      }
      
      // Function to show empty state
      function showEmptyState(message) {
        streamGrid.innerHTML = `
          <div class="empty-message">
            <p>${message}</p>
          </div>
        `;
      }
      
      // === DASHBOARD FRAME CAPTURE FUNCTIONS ===
      
      // Function to capture a frame from a video element
      function captureFrameFromVideo(broadcasterId) {
        const videoElement = document.getElementById(`video-${broadcasterId}`);
        
        if (!videoElement || videoElement.readyState < 2) {
          console.log(`[DASHBOARD] Cannot capture frame - video not ready for ${broadcasterId}`);
          return null;
        }
        
        try {
          // Create a canvas to capture the frame
          const canvas = document.createElement('canvas');
          canvas.width = videoElement.videoWidth || 640;
          canvas.height = videoElement.videoHeight || 480;
          
          const ctx = canvas.getContext('2d');
          ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
          
          // Convert to data URL (base64 image) with quality from config
          const frameDataUrl = canvas.toDataURL('image/jpeg', FRAME_QUALITY);
          
          console.log(`[DASHBOARD] Captured frame from ${broadcasterId}`);
          
          return {
            id: Date.now() + Math.random(), // Unique ID for this frame
            broadcasterId: broadcasterId,
            broadcasterName: getBroadcasterName(broadcasterId),
            timestamp: new Date().toISOString(),
            dataUrl: frameDataUrl
          };
        } catch (err) {
          console.error(`[DASHBOARD] Error capturing frame from ${broadcasterId}:`, err);
          return null;
        }
      }
      
      // Function to get broadcaster name
      function getBroadcasterName(broadcasterId) {
        const cell = document.getElementById(`cell-${broadcasterId}`);
        if (cell) {
          const nameElement = cell.querySelector('.stream-title span');
          return nameElement ? nameElement.textContent : broadcasterId;
        }
        return broadcasterId;
      }
      
      // Function to add frame to dashboard (FIFO queue)
      function addFrameToDashboard(frame) {
        if (!frame) return;
        
        // Store current broadcaster ID for threshold alerts
        window.currentBroadcasterId = frame.broadcasterId;
        
        // Add frame to the beginning of the array
        capturedFrames.unshift(frame);
        
        // If we exceed max frames, remove the oldest (from the end)
        if (capturedFrames.length > MAX_FRAMES) {
          capturedFrames = capturedFrames.slice(0, MAX_FRAMES);
        }
        
        console.log(`[DASHBOARD] Frame added. Total frames: ${capturedFrames.length}`);
        
        // Generate sensor data for this frame capture
        const { co2, ch4 } = generateSensorData();
        addSensorDataPoint(co2, ch4);
        
        // Send frame for fire/smoke detection
        analyzeFrameForFire(frame);
        
        // Update the dashboard display
        updateDashboard();
      }
      
      // Send frame to server for YOLOv8 fire/smoke detection
      async function analyzeFrameForFire(frame) {
        try {
          console.log(`[YOLO] Sending frame for analysis from ${frame.broadcasterId}`);
          
          // Use full server URL for API calls (important for production/GitHub Pages)
          const serverUrl = CONFIG.getServerUrl();
          const response = await fetch(`${serverUrl}/api/analyze-frame`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              image: frame.dataUrl,
              broadcasterId: frame.broadcasterId,
              timestamp: frame.timestamp
            })
          });
          
          if (!response.ok) {
            throw new Error(`Server error: ${response.status}`);
          }
          
          const result = await response.json();
          
          // Display detection results
          displayDetectionResult(result, frame);
          
          // Check for fire/smoke and raise alert if detected
          if (result.success && result.fire_detected) {
            raiseFireAlert(frame.broadcasterId, result.detections, frame.dataUrl);
          } else if (result.success) {
            console.log(`[YOLO] Analysis complete: ${result.num_detections} objects detected, no fire/smoke`);
          } else {
            console.error('[YOLO] Analysis failed:', result.error);
          }
        } catch (error) {
          console.error('[YOLO] Failed to analyze frame:', error);
        }
      }
      
      // Display detection results in the UI (Stack of 3)
      function displayDetectionResult(result, frame) {
        const resultsContainer = document.getElementById('detectionResults');
        
        // Remove empty message if present
        const emptyMsg = resultsContainer.querySelector('.detection-empty');
        if (emptyMsg) {
          emptyMsg.remove();
        }
        
        // Check if we need to create the stack container
        let stackContainer = resultsContainer.querySelector('.detection-stack');
        if (!stackContainer) {
          stackContainer = document.createElement('div');
          stackContainer.className = 'detection-stack';
          resultsContainer.appendChild(stackContainer);
        }
        
        // Create detection item
        const detectionItem = document.createElement('div');
        detectionItem.className = `detection-stack-item latest ${result.fire_detected ? 'fire-detected' : ''}`;
        
        const timestamp = new Date(frame.timestamp).toLocaleTimeString();
        
        let html = `
          <div class="detection-header">
            <span class="detection-broadcaster">üìπ ${frame.broadcasterId}</span>
            <span class="detection-timestamp">${timestamp}</span>
          </div>
          <div class="detection-summary">
        `;
        
        if (result.success) {
          if (result.fire_detected) {
            html += `<span class="detection-badge fire">üî• FIRE/SMOKE DETECTED!</span>`;
          } else {

            html += `<span class="detection-badge safe">‚úì No Fire Detected</span>`;
          }
          html += `<span class="detection-badge info">${result.num_detections} object(s)</span>`;
          
          // Add detected objects
          if (result.detections && result.detections.length > 0) {
            html += `</div><div class="detection-objects">`;
            result.detections.forEach(det => {
              const confidence = Math.round(det.confidence * 100);
              const emoji = getObjectEmoji(det.class);
              html += `<span class="object-tag">${emoji} ${det.class}<span class="confidence">${confidence}%</span></span>`;
            });
          }
        } else {
          html += `<span class="detection-badge fire">‚ùå Analysis Failed</span>`;
        }
        
        html += `</div>`;
        detectionItem.innerHTML = html;
        
        // Remove 'latest' class from all items
        stackContainer.querySelectorAll('.detection-stack-item').forEach(item => {
          item.classList.remove('latest');
        });
        
        // Add to top of stack
        stackContainer.insertBefore(detectionItem, stackContainer.firstChild);
        
        // Keep only last 3 results
        const items = stackContainer.querySelectorAll('.detection-stack-item');
        if (items.length > 3) {
          items[items.length - 1].remove();
        }
      }
      
      // Get emoji for object class
      function getObjectEmoji(className) {
        const emojiMap = {
          'person': 'üë§',
          'fire': 'üî•',
          'smoke': 'üí®',
          'car': 'üöó',
          'truck': 'üöö',
          'dog': 'üêï',
          'cat': 'üê±',
          'bird': 'üê¶',
          'chair': 'ü™ë',
          'bottle': 'üçæ',
          'cup': '‚òï',
          'laptop': 'üíª',
          'phone': 'üì±',
          'tv': 'üì∫',
          'book': 'üìñ'
        };
        return emojiMap[className.toLowerCase()] || 'üì¶';
      }

      
      // Function to update the dashboard display
      function updateDashboard() {
        // Update frame count
        frameCountElement.textContent = `${capturedFrames.length} / ${MAX_FRAMES} frames captured`;
        
        // Clear dashboard
        dashboardGrid.innerHTML = '';
        
        if (capturedFrames.length === 0) {
          dashboardGrid.innerHTML = `
            <div class="dashboard-empty">
              <p>No frames captured yet</p>
              <p style="font-size: 12px; margin-top: 8px;">Frames will be automatically captured from all active streams</p>
            </div>
          `;
          return;
        }
        
        // Render all frames
        capturedFrames.forEach((frame, index) => {
          const frameCard = document.createElement('div');
          frameCard.className = 'frame-card';
          
          const timeAgo = getTimeAgo(new Date(frame.timestamp));
          
          frameCard.innerHTML = `
            <img src="${frame.dataUrl}" class="frame-image" alt="Captured frame">
            <div class="frame-info">
              <div>
                <div class="frame-broadcaster">${frame.broadcasterName}</div>
                <div class="frame-timestamp">${timeAgo}</div>
              </div>
              <div style="font-size: 10px; color: #6b7280;">#${capturedFrames.length - index}</div>
            </div>
          `;
          
          dashboardGrid.appendChild(frameCard);
        });
      }
      
      // Function to get relative time string
      function getTimeAgo(date) {
        const seconds = Math.floor((new Date() - date) / 1000);
        
        if (seconds < 60) return `${seconds}s ago`;
        const minutes = Math.floor(seconds / 60);
        if (minutes < 60) return `${minutes}m ago`;
        const hours = Math.floor(minutes / 60);
        if (hours < 24) return `${hours}h ago`;
        const days = Math.floor(hours / 24);
        return `${days}d ago`;
      }
      
      // Function to start capturing frames from a broadcaster
      function startFrameCapture(broadcasterId) {
        // Don't start if already capturing
        if (captureIntervals[broadcasterId]) {
          console.log(`[DASHBOARD] Already capturing from ${broadcasterId}`);
          return;
        }
        
        console.log(`[DASHBOARD] Starting frame capture for ${broadcasterId}`);
        
        // Capture first frame immediately (after a short delay to ensure video is ready)
        setTimeout(() => {
          const frame = captureFrameFromVideo(broadcasterId);
          if (frame) addFrameToDashboard(frame);
        }, 2000);
        
        // Set up interval to capture frames periodically
        const intervalId = setInterval(() => {
          const frame = captureFrameFromVideo(broadcasterId);
          if (frame) {
            addFrameToDashboard(frame);
          }
        }, CAPTURE_INTERVAL);
        
        captureIntervals[broadcasterId] = intervalId;
      }
      
      // Function to stop capturing frames from a broadcaster
      function stopFrameCapture(broadcasterId) {
        if (captureIntervals[broadcasterId]) {
          console.log(`[DASHBOARD] Stopping frame capture for ${broadcasterId}`);
          clearInterval(captureIntervals[broadcasterId]);
          delete captureIntervals[broadcasterId];
        }
      }
      
      // Update dashboard timestamps periodically
      setInterval(() => {
        if (capturedFrames.length > 0) {
          updateDashboard();
        }
      }, 10000); // Update every 10 seconds to refresh "time ago" text
      
      // === ENVIRONMENTAL DATA FETCHING ===
      
      // Fetch environmental data (weather + air quality)
      async function fetchEnvironmentalData() {
        const container = document.getElementById('envDataContainer');
        container.innerHTML = '<div class="env-data-loading">üåê Fetching environmental data...</div>';
        
        try {
          // Get user's location
          const position = await new Promise((resolve, reject) => {
            if (!navigator.geolocation) {
              reject(new Error('Geolocation not supported'));
            }
            navigator.geolocation.getCurrentPosition(resolve, reject);
          });
          
          const { latitude, longitude } = position.coords;
          
          // Fetch weather and air quality data using Open-Meteo (free, no API key needed!)
          const weatherResponse = await fetch(
            `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,relative_humidity_2m,wind_speed_10m,weather_code&timezone=auto`
          );
          
          const airQualityResponse = await fetch(
            `https://air-quality-api.open-meteo.com/v1/air-quality?latitude=${latitude}&longitude=${longitude}&current=pm10,pm2_5,carbon_monoxide,nitrogen_dioxide,ozone&timezone=auto`
          );
          
          if (!weatherResponse.ok || !airQualityResponse.ok) {
            throw new Error('Failed to fetch environmental data');
          }
          
          const weatherData = await weatherResponse.json();
          const airQualityData = await airQualityResponse.json();
          
          displayEnvironmentalData(weatherData, airQualityData, latitude, longitude);
          
        } catch (error) {
          console.error('Error fetching environmental data:', error);
          container.innerHTML = `
            <div class="env-data-error">
              ‚ùå Could not fetch environmental data
              <br><small>${error.message === 'User denied Geolocation' ? 'Please enable location access' : error.message}</small>
            </div>
          `;
        }
      }
      
      // Display environmental data in cards
      function displayEnvironmentalData(weather, airQuality, lat, lon) {
        const container = document.getElementById('envDataContainer');
        
        const temp = weather.current.temperature_2m;
        const humidity = weather.current.relative_humidity_2m;
        const windSpeed = weather.current.wind_speed_10m;
        
        const pm25 = airQuality.current.pm2_5;
        const pm10 = airQuality.current.pm10;
        const co = airQuality.current.carbon_monoxide;
        const no2 = airQuality.current.nitrogen_dioxide;
        const o3 = airQuality.current.ozone;
        
        // Calculate AQI level
        const aqiLevel = getAQILevel(pm25, pm10);
        const coLevel = getCOLevel(co);
        
        container.innerHTML = `
          <div class="env-data-grid">
            <div class="env-data-card">
              <div class="env-card-label">üå°Ô∏è Temperature</div>
              <div class="env-card-value">${temp.toFixed(1)}¬∞C</div>
              <div class="env-card-info">Humidity: ${humidity}%</div>
            </div>
            
            <div class="env-data-card">
              <div class="env-card-label">üí® Wind Speed</div>
              <div class="env-card-value">${windSpeed.toFixed(1)} km/h</div>
              <div class="env-card-info">Current conditions</div>
            </div>
            
            <div class="env-data-card ${aqiLevel.class}">
              <div class="env-card-label">üè≠ Air Quality (PM2.5)</div>
              <div class="env-card-value">${pm25.toFixed(1)} ¬µg/m¬≥</div>
              <div class="env-card-info">${aqiLevel.text}</div>
            </div>
            
            <div class="env-data-card ${coLevel.class}">
              <div class="env-card-label">üî¨ Carbon Monoxide</div>
              <div class="env-card-value">${co.toFixed(0)} ¬µg/m¬≥</div>
              <div class="env-card-info">${coLevel.text}</div>
            </div>
            
            <div class="env-data-card">
              <div class="env-card-label">üå´Ô∏è Nitrogen Dioxide</div>
              <div class="env-card-value">${no2.toFixed(1)} ¬µg/m¬≥</div>
              <div class="env-card-info">NO‚ÇÇ levels</div>
            </div>
            
            <div class="env-data-card">
              <div class="env-card-label">‚òÅÔ∏è Ozone</div>
              <div class="env-card-value">${o3.toFixed(1)} ¬µg/m¬≥</div>
              <div class="env-card-info">O‚ÇÉ concentration</div>
            </div>
          </div>
          <div class="location-info">
            üìç Location: ${lat.toFixed(4)}¬∞, ${lon.toFixed(4)}¬∞ ‚Ä¢ Last updated: ${new Date().toLocaleTimeString()}
          </div>
        `;
      }
      
      // Get AQI level from PM2.5 and PM10
      function getAQILevel(pm25, pm10) {
        if (pm25 <= 12) return { text: 'Good air quality', class: '' };
        if (pm25 <= 35) return { text: 'Moderate air quality', class: 'warning' };
        if (pm25 <= 55) return { text: 'Unhealthy for sensitive groups', class: 'warning' };
        return { text: 'Unhealthy air quality', class: 'danger' };
      }
      
      // Get CO level assessment
      function getCOLevel(co) {
        if (co <= 4000) return { text: 'Normal levels', class: '' };
        if (co <= 9000) return { text: 'Moderate levels', class: 'warning' };
        return { text: 'High levels', class: 'danger' };
      }
      
      // Fetch environmental data on page load
      fetchEnvironmentalData();
      
      // Refresh environmental data every 10 minutes
      setInterval(fetchEnvironmentalData, 600000);
    </script>
  </body>
</html>